<!DOCTYPE HTML>
<html><head><link href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" rel="stylesheet"><link href="https://lowerbound.io/style1.css" rel="stylesheet"><link href="https://lowerbound.io/style2.css" rel="stylesheet"><script type="text/javascript">document.documentElement.className = document.documentElement.className.replace(/no-js/,'js');</script><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script src="jquery.waypoints.min.js"></script><script src="jquery.isonscreen.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script><script type="text/javascript" async="true" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML"></script><script type="text/javascript" src="https://lowerbound.io/script.js"></script><style type="text/css">.MathJax_Preview {color: #888} #MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap} #MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px} .MathJax_Error {color: #CC0000; font-style: italic}</style></head><body><div class="outerContainer"><div id="main"><div id="top_container"><div id="header"><div id="header_container"><div id="address"><h2 id="myname">Peter Robinson</h2><p class="email"><a href="mailto:peter(at)lowerbound(dot)io">peter at lowerbound dot io</a></p></div><div id="mypic"><img id="myimg" src="pic.jpg" alt="" width="156" height="204"></div></div><ul id="nav"><li><a class="navLink" id="about" href="#About">About</a></li><li><a class="navLink" id="publications" href="#Publications">Publications</a></li><li><a class="navLink" id="code" href="#Code">Code</a></li><li><a class="navLink" id="teaching" href="#Teaching">Teaching</a></li><li><a class="navLink" id="misc" href="#Misc">Misc</a></li></ul></div></div><div class="mycontainer" class="anchor" id="About"><div class="intro">My research focuses on designing new distributed and parallel algorithms, the distributed processing of big data, achieving fault-tolerance in communication networks against adversarial attacks, and developing robust protocols that work in highly dynamic environments such as peer-to-peer Blockchain networks and mobile ad-hoc networks.</div><div class="intro"><h2>News</h2><ul id="newsList" class="fa-ul"><li><i class="fa fa-li fa-caret-right"></i>General Chair of ACM PODC 2019</li><li><i class="fa fa-li fa-caret-right"></i>Program committee member of <a href="http://www.podc.org">PODC 2020</a>, <a href="http://www.podc.org">SIROCCO 2020</a>, <a href="http://www.disc-conference.org/wp/">DISC 2019</a></li></ul></div><div class="tagCloud"><h2 class="tagCloud">Tags </h2><a class="keyword" style="font-size: 1.5372436em" href="https://lowerbound.io//tags/Asynchrony.html#Publications"> Asynchrony  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Big Data.html#Publications"> Big Data  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Byzantine Failures.html#Publications"> Byzantine Failures  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Churn.html#Publications"> Churn  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Communication Complexity.html#Publications"> Communication Complexity  </a><a class="keyword" style="font-size: 1.8510257em" href="https://lowerbound.io//tags/Distributed Agreement.html#Publications"> Distributed Agreement  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Distributed Storage.html#Publications"> Distributed Storage  </a><a class="keyword" style="font-size: 1.7124022em" href="https://lowerbound.io//tags/Dynamic Network.html#Publications"> Dynamic Network  </a><a class="keyword" style="font-size: 2.0em" href="https://lowerbound.io//tags/Fault-Tolerance.html#Publications"> Fault-Tolerance  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Gossip Communication.html#Publications"> Gossip Communication  </a><a class="keyword" style="font-size: 1.761878em" href="https://lowerbound.io//tags/Graph Algorithm.html#Publications"> Graph Algorithm  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Haskell.html#Publications"> Haskell  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Information Complexity.html#Publications"> Information Complexity  </a><a class="keyword" style="font-size: 1.5372436em" href="https://lowerbound.io//tags/Leader Election.html#Publications"> Leader Election  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Machine Learning.html#Publications"> Machine Learning  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Mobile Ad-Hoc Network.html#Publications"> Mobile Ad-Hoc Network  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Natural Language Processing.html#Publications"> Natural Language Processing  </a><a class="keyword" style="font-size: 1.4669032em" href="https://lowerbound.io//tags/P2P.html#Publications"> P2P  </a><a class="keyword" style="font-size: 1.6008743em" href="https://lowerbound.io//tags/Secure Computation in Networks.html#Publications"> Secure Computation in Networks  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Self-Healing.html#Publications"> Self-Healing  </a><a class="keyword" style="font-size: 1.2991215em" href="https://lowerbound.io//tags/Symmetry Breaking.html#Publications"> Symmetry Breaking  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Wireless Networks.html#Publications"> Wireless Networks  </a></div><h2><a class="anchor" id="Publications">Publications</a></h2><div class="publicationList"><div class="yearContainer"><span class="year">2020</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">DConstructor: Efficient and Robust Network Construction with Polylogarithmic Overhead.</span><br>Seth Gilbert, Gopal Pandurangan, Peter Robinson, Amitabh Trehan. <span class="publicationInfo">39th ACM Symposium on Principles of Distributed Computing</span> (<span class="publicationConfShort">PODC 2020</span>). <br></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Latency, Capacity, and Distributed Minimum Spanning Tree.</span><br>John Augustine, Seth Gilbert, Fabian Kuhn, Peter Robinson, Suman Sourav. <span class="publicationInfo">40th IEEE International Conference on Distributed Computing Systems</span> (<span class="publicationConfShort">ICDCS 2020</span>). <br></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">A Time- and Message-Optimal Distributed Algorithm for Minimum Spanning Trees</span><br>Gopal Pandurangan, Peter Robinson, Michele Scquizzato. <span class="publicationInfo">ACM Transactions on Algorithms</span> (<span class="publicationConfShort">ACM TALG</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">This paper presents a randomized (Las Vegas) distributed algorithm that constructs a minimum spanning tree (MST) in weighted networks with optimal (up to polylogarithmic factors) time and message complexity.  This algorithm  runs in $\tilde{O}(D + \sqrt{n})$ time and exchanges $\tilde{O}(m)$ messages (both with high probability), where $n$ is the number of nodes of the network, $D$ is the diameter, and $m$ is the number of edges.  This is the first distributed MST algorithm that matches simultaneously the time lower bound of $\tilde{\Omega}(D + \sqrt{n})$ [Elkin, SIAM J. Comput. 2006] and the message lower bound of $\Omega(m)$ [Kutten et al., JACM 2015], which both apply to randomized Monte Carlo algorithms.  The prior time and message lower bounds are  derived using two completely different graph constructions; the existing lower bound construction that shows one lower bound does not work for the other.  To complement our algorithm, we  present a new lower bound graph construction for which any distributed MST algorithm  requires both $\tilde{\Omega}(D + \sqrt{n})$ rounds and $\Omega(m)$ messages.</div></li></ul></div><div class="yearContainer"><span class="year">2019</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">The Complexity of Symmetry Breaking in Massive Graphs.</span><a href="http://drops.dagstuhl.de/opus/volltexte/2019/11333/" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Christian Konrad, Sriram V. Pemmaraju, Talal Riaz, and Peter Robinson. <span class="publicationInfo">32nd International Symposium on Distributed Computing LIPIcs, Vol. 146</span> (<span class="publicationConfShort">DISC 2019</span>). <br></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Slow Links, Fast Links, and the Cost of Gossip.</span><a href="https://doi.org/10.1109/TPDS.2019.2905568" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Seth Gilbert, Peter Robinson, Suman Sourav. <span class="publicationInfo">IEEE Transactions on Parallel and Distributed Systems</span> (<span class="publicationConfShort">IEEE TPDS</span>). <br></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">The complexity of leader election in diameter-two networks.</span><a href="https://www.springerprofessional.de/en/the-complexity-of-leader-election-in-diameter-two-networks/16740182" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Soumyottam Chatterjee, Gopal Pandurangan, Peter Robinson. <span class="publicationInfo">Distributed Computing</span> (<span class="publicationConfShort">DC</span>). <br></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Network Size Estimation in Small-World Networks under Byzantine Faults.</span><a href="https://doi.org/10.1109/IPDPS.2019.00094" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Soumyottam Chatterjee, Gopal Pandurangan, Peter Robinson. <span class="publicationInfo">33rd IEEE International Parallel and Distributed Processing Symposium</span> (<span class="publicationConfShort">IPDPS 2019</span>). <br></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">On the Hardness of the Strongly Dependent Decision Problem.</span><br>Martin Biely and Peter Robinson. <span class="publicationInfo">20th International Conference on Distributed Computing and Networking</span> (<span class="publicationConfShort">ICDCN 2019</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">We present necessary and sufficient conditions for solving the strongly dependent decision (SDD) problem in various distributed systems. Our main contribution is a novel characterization of the SDD problem based on point-set topology. For partially synchronous systems, we show that any algorithm that solves the SDD problem induces a set of executions that is closed with respect to the point-set topology. We also show that the SDD problem is not solvable in the asynchronous system augmented with any arbitrarily strong failure detectors.</div></li></ul></div><div class="yearContainer"><span class="year">2018</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Fault-Tolerant Consensus with an Abstract MAC Layer.</span><br>Calvin Newport and Peter Robinson. <span class="publicationInfo">32nd International Symposium on Distributed Computing</span> (<span class="publicationConfShort">DISC 2018</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">In this paper, we study fault-tolerant distributed consensus in wireless systems. In more detail, we produce two new randomized algorithms that solve this problem in the abstract MAC layer model, which captures the basic interface and communication guarantees provided by most wireless MAC layers. Our algorithms work for any number of failures,  require no advance knowledge of the network participants or network size, and guarantee termination with high probability after a number of broadcasts that are polynomial in the network size. Our first algorithm satisfies the standard agreement property, while our second trades a faster termination guarantee in exchange for a looser agreement property in which most nodes agree on the same value. These are the first known fault-tolerant consensus algorithms for this model. In addition to our main upper bound results, we explore the gap between the abstract MAC layer and the standard asynchronous message passing model by proving fault-tolerant consensus is impossible in the latter in the absence of information regarding the network participants, even if we assume no faults, allow randomized solutions, and provide the algorithm a constant-factor approximation of the network size.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Leader Election in Well-Connected Graphs</span><br>Seth Gilbert, Peter Robinson, Suman Sourav. <span class="publicationInfo">37th ACM Symposium on Principles of Distributed Computing</span> (<span class="publicationConfShort">PODC 2018</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">In this paper, we look at the problem of randomized leader election in synchronous distributed networks with a special focus on the message complexity. We provide an algorithm  that solves the implicit version of leader election (where non-leader nodes  need not be aware of the identity of the leader) in any general network with $O(\sqrt{n} \log^{7/2} n \cdot t_{mix})$ messages and in $O(t_{mix}\log^2 n)$ time, where $n$ is the number of nodes and $t_{mix}$ refers to the mixing time of a random walk in the network graph $G$. For several classes of well-connected networks (that have a large conductance or alternatively small mixing times e.g. expanders, hypercubes, etc), the above result implies extremely efficient (sublinear running time and messages) leader election algorithms. Correspondingly, we show that any substantial improvement is not possible over our algorithm, by presenting an almost matching lower bound for randomized leader election. We show that $\Omega(\sqrt{n}/\phi^{3/4})$ messages are needed for any leader election algorithm that succeeds with probability at least $1-o(1)$, where $\phi$ refers to the conductance of a graph. To the best of our knowledge, this is the first work that shows a dependence between the time and message complexity to solve leader election and the connectivity of the graph $G$, which is often characterized by the graph&#39;s conductance $\phi$. Apart from the $\Omega(m)$ bound in Kutten et al 2015 (where $m$ denotes the number of edges of the graph), this work also provides one of the first non-trivial lower bounds for leader election in general networks.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">On the Distributed Complexity of Large-Scale Graph Computations</span><a href="https://arxiv.org/abs/1602.08481" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Gopal Pandurangan, Peter Robinson, Michele Scquizzato. <span class="publicationInfo">30th ACM Symposium on Parallelism in Algorithms and Architectures.</span> (<span class="publicationConfShort">SPAA 2018</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">Motivated by the need to understand the algorithmic foundations of distributed large-scale graph computations, we study some fundamental graph problems in a message-passing model for distributed computing where $k \geq 2$ machines jointly perform computations on graphs with $n$ nodes (typically, $n \gg k$).  The input graph is assumed to be initially randomly partitioned among the $k$ machines, a common implementation in many real-world systems. Communication is point-to-point, and the goal is to minimize the number of communication rounds of the computation.  We present (almost) tight bounds for the round complexity of two fundamental graph problems, namely triangle enumeration and PageRank computation.  Our tight lower bounds, a main contribution of the paper, are established through an information-theoretic approach that relates the round complexity to the minimal amount of information required by machines for solving a problem. Our approach is generic and can be useful in showing lower bounds in the context of similar problems and similar models. Our approach, as demonstrated in the case of triangle enumeration, can yield stronger round lower bounds as well as message-round tradeoffs compared to approaches that use communication complexity techniques.  We then present algorithms that (almost) match the lower bounds; these algorithms exhibit a round complexity which scales superlinearly in $k$, improving significantly over previous results.  Specifically, we show the following results: 1. Triangle enumeration: We show that there exist graphs with $m$ edges where any distributed algorithm requires  $\tilde{\Omega}(m/k^{5/3})$ rounds. This result implies the first non-trivial lower bound of $\tilde\Omega(n^{1/3})$ rounds for the congested clique model, which is tight up to logarithmic factors.  We also present a distributed algorithm that enumerates  all the triangles of a graph in $\tilde{O}(m/k^{5/3})$ rounds.  2. PageRank: We show a lower bound of $\tilde{\Omega}(n/k^2)$ rounds, and present a simple distributed algorithm that computes the PageRank of all the nodes of a graph in $\tilde{O}(n/k^2)$ rounds.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Breaking the $\Omega(\sqrt{n})$ Barrier: Fast Consensus under a Late Adversary</span><a href="http://doi.acm.org/10.1145/3210377.3210399" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Peter Robinson, Christian Scheideler, Alexander Setzer. <span class="publicationInfo">30th ACM Symposium on Parallelism in Algorithms and Architectures.</span> (<span class="publicationConfShort">SPAA 2018</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">We study the consensus problem in a synchronous distributed system of $n$ nodes under an adaptive adversary that has a slightly outdated view of the system and can block all incoming and outgoing communication of a constant fraction of the nodes in each round.  Motivated by a result of Ben-Or and Bar-Joseph (1998), showing that any consensus algorithm that is resilient against a linear number of crash faults requires $\tilde \Omega(\sqrt{n})$ rounds in an $n$-node network against an adaptive adversary, we consider a late adaptive adversary, who has full knowledge of the network state at the beginning of the previous round and unlimited computational power, but is oblivious to the current state of the nodes.  Our main contributions are randomized distributed algorithms that achieve consensus with high probability among all except a small constant fraction of the nodes (i.e., ``almost-everywhere&#39;&#39;) against a late adaptive adversary who can block up to $\epsilon n$ nodes in each round, for a small constant $\epsilon &gt;0$.  Our first protocol achieves binary almost-everywhere consensus and also guarantees a decision on the majority input value, thus ensuring plurality consensus.  We also present an algorithm that achieves the same time complexity for multi-value consensus.  Both of our algorithms succeed in $O(\log n)$ rounds with high probability, thus breaking the known $\tilde\Omega(\sqrt{n})$ lower bound for fully adaptive  adversaries.  Our algorithms are scalable to large systems as each node contacts only an (amortized) constant number of peers in each communication round.  We show that our algorithms are optimal up to constant (resp. sub-logarithmic) factors by proving that every almost-everywhere consensus protocol takes $\Omega(\log_d n)$ rounds in the worst case, where $d$ is an upper bound on the number of communication requests initiated per node in each round.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Slow Links, Fast Links, and the Cost of Gossip</span><a href="http://doi.ieeecomputersociety.org/10.1109/ICDCS.2018.00081" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Seth Gilbert, Peter Robinson, Suman Sourav. <span class="publicationInfo">38th IEEE International Conference on Distributed Computing Systems</span> (<span class="publicationConfShort">ICDCS 2018</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">Consider the classical problem of information dissemination: one (or more) nodes in a network have some information that they want to distribute to the remainder of the network.  In this paper, we study the cost of information dissemination in networks where edges have latencies, i.e., sending a message from one node to another takes some amount of time.  We first generalize the idea of conductance to weighted graphs, defining $\phi_*$ to be the ``weighted conductance&#39;&#39; and $\ell_*$ to be the ``critical latency.&#39;&#39;  One goal of this paper is to argue that $\phi_*$ characterizes the connectivity of a weighted graph with latencies in much the same way that conductance characterizes the connectivity of unweighted graphs.  We give near tight upper and lower bounds on the problem of information dissemination, up to polylogarithmic factors.  Specifically, we show that in a graph with (weighted) diameter $D$ (with latencies as weights), maximum degree $\Delta$, weighted conductance $\phi_*$ and critical latency $\ell_*$, any information dissemination algorithm requires at least $\Omega(\min(D+\Delta, \ell_*/\phi_*))$ time. We show several variants of the lower bound (e.g., for graphs with small diameter, graphs with small max-degree, etc.) by reduction to a simple combinatorial game.  We then give nearly matching algorithms, showing that information dissemination can be solved in $O(\min((D + \Delta)\log^3{n}), (\ell_*/\phi_*)\log(n))$ time.  % $O(\min(D\log^3(n), \ell_*\log(n)/\phi_*))$.  The algorithm consists of two sub-algorithms: This is achieved by combining two cases.  When nodes do not know the latency of the adjacent edges, we show that the classical push-pull algorithm is (near) optimal when the diameter or maximum degree is large.  For the case where the diameter and maximum degree are small, we give an alternative strategy in which we first discover the latencies and then use an algorithm for known latencies based on a weighted spanner construction.  (Our algorithms are within polylogarithmic factors of being tight both for known and unknown latencies.) </div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">The Complexity of Leader Election: A Chasm at Diameter Two</span><a href="http://doi.acm.org/10.1145/3087801.3087865" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Soumyottam Chatterjee, Gopal Pandurangan, Peter Robinson. <span class="publicationInfo">19th International Conference on Distributed Computing and Networking</span> (<span class="publicationConfShort">ICDCN 2018</span>). <span class="bestPaper"><br>Top Nomination for Best Paper Award.</span><br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">Leader election is one of the fundamental problems  in distributed computing. In its implicit version, only the leader must know who is the elected leader. This paper focuses on studying the message complexity of  leader election  in synchronous  distributed networks, in particular, in  networks of diameter two. Kutten et al. [JACM 2015] showed a fundamental lower bound of $\Omega(m)$ ($m$ is the number of edges in the network) on the message complexity of (implicit)  leader election that applied also to  Monte Carlo randomized algorithms with constant success probability; this lower bound applies for graphs that have {diameter at least three}. On the other hand, for complete graphs (i.e., diameter 1), Kutten et al. [TCS 2015] established a tight bound of $\tilde{\Theta}(\sqrt{n})$ on the message complexity of randomized leader election ($n$ is the number of nodes in the network). For graphs of diameter two, the complexity was not known.  In this paper, we settle this complexity by showing a tight bound of $\tilde{\Theta}(n)$ on the message complexity of leader election in diameter-two networks. We first give a simple randomized Monte-Carlo leader election algorithm that with high probability (i.e., probability at least $1 - n^{-c}$, for some positive constant $c$) succeeds and  uses $O(n\log^3{n})$ messages and runs in $O(1)$ rounds; this algorithm works without knowledge of $n$ (and hence needs no global knowledge). We then show that any  algorithm (even Monte Carlo  randomized algorithms with large enough constant success probability) needs $\Omega(n)$ messages (even when $n$ is known), regardless of the number of rounds. We also present an $O(n\log{n})$ messages deterministic algorithm  that takes $O(\log{n})$ rounds (but needs knowledge of $n$); we show that this message complexity is tight for deterministic algorithms. Our results show that leader election can be solved in diameter-two graphs in (essentially) linear (in $n$) message complexity and thus the $\Omega(m)$ lower bound does not apply to diameter-two graphs.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Gracefully Degrading Consensus and k-Set Agreement in Directed Dynamic Networks</span><br>Martin Biely, Peter Robinson, Ulrich Schmid, Manfred Schwarz, Kyrill Winkler. <span class="publicationInfo">Theoretical Computer Science 726: 41-77 (2018)</span> (<span class="publicationConfShort">TCS</span>). <br></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Fast Distributed Algorithms for Connectivity and MST in Large Graphs</span><br>Gopal Pandurangan, Peter Robinson, Michele Scquizzato. <span class="publicationInfo">Special Issue of ACM Transactions on Parallel Computing.</span> (<span class="publicationConfShort">TOPC</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">Motivated by the increasing need to understand the algorithmic foundations of distributed large-scale graph computations, we study a number of fundamental graph problems in a message-passing model for distributed computing where $k \geq 2$ machines jointly perform computations on graphs with $n$ nodes (typically, $n \gg k$).  The input graph is assumed to be initially randomly partitioned among the $k$ machines, a common implementation in many real-world systems. Communication is point-to-point, and the goal is to minimize the number of communication rounds of the computation.  Our main result is an (almost) optimal  distributed randomized algorithm for graph connectivity.  Our algorithm runs in $\tilde{O}(n/k^2)$ rounds ($\tilde{O}$ notation hides a $\text{polylog}(n)$ factor and an additive $\text{polylog}(n)$ term). This improves over the best previously known bound of $\tilde{O}(n/k)$ [Klauck et al., SODA 2015], and is optimal (up to a polylogarithmic factor) in view of an existing lower bound of $\tilde{\Omega}(n/k^2)$. Our improved algorithm uses a bunch of techniques, including linear graph sketching, that prove useful in the design of efficient distributed graph algorithms.  We then present fast randomized algorithms for computing minimum spanning trees, (approximate) min-cuts, and for many graph verification problems. All these algorithms take $\tilde{O}(n/k^2)$ rounds, and are optimal up to polylogarithmic factors.  We also show an almost matching lower bound of $\tilde{\Omega}(n/k^2)$ for many graph verification problems using lower bounds in random-partition communication complexity.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">The Distributed Minimum Spanning Tree Problem</span><a href="http://bulletin.eatcs.org/index.php/beatcs/article/view/538/538" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Gopal Pandurangan, Peter Robinson, Michele Scquizzato. <span class="publicationInfo">Distributed Computing Column, EATCS Bulletin, No 125: June 2018.</span> (<span class="publicationConfShort">EATCS</span>). <br></li></ul></div><div class="yearContainer"><span class="year">2017</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">A Time- and Message-Optimal Distributed Algorithm for Minimum Spanning Trees</span><a href="https://doi.org/10.1145/3055399.3055449" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Gopal Pandurangan, Peter Robinson, Michele Scquizzato. <span class="publicationInfo">49th ACM Symposium on Theory of Computing</span> (<span class="publicationConfShort">STOC 2017</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">This paper presents a randomized (Las Vegas) distributed algorithm that constructs a minimum spanning tree (MST) in weighted networks with optimal (up to polylogarithmic factors) time and message complexity.  This algorithm  runs in $\tilde{O}(D + \sqrt{n})$ time and exchanges $\tilde{O}(m)$ messages (both with high probability), where $n$ is the number of nodes of the network, $D$ is the diameter, and $m$ is the number of edges.  This is the first distributed MST algorithm that matches simultaneously the time lower bound of $\tilde{\Omega}(D + \sqrt{n})$ [Elkin, SIAM J. Comput. 2006] and the message lower bound of $\Omega(m)$ [Kutten et al., JACM 2015], which both apply to randomized Monte Carlo algorithms.  The prior time and message lower bounds are  derived using two completely different graph constructions; the existing lower bound construction that shows one lower bound does not work for the other.  To complement our algorithm, we  present a new lower bound graph construction for which any distributed MST algorithm  requires both $\tilde{\Omega}(D + \sqrt{n})$ rounds and $\Omega(m)$ messages.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Symmetry Breaking in the Congest Model: Message- and Time-Efficient Algorithms for Ruling Sets.</span><br>Shreyas Pai, Gopal Pandurangan, Sriram V. Pemmaraju, Talal Riaz, Peter Robinson. <span class="publicationInfo">31st International Symposium on Distributed Computing</span> (<span class="publicationConfShort">DISC 2017</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">We study local symmetry breaking problems in the Congest model, focusing on ruling set problems, which generalize the fundamental Maximal Independent Set (MIS) problem. The time (round) complexity of MIS (and ruling sets) have attracted much attention in the Local model. Indeed, recent results (Barenboim et al., FOCS 2012, Ghaffari SODA 2016) for the MIS problem have tried to break the long-standing $O(\log n)$-round ``barrier&#39;&#39; achieved by Luby&#39;s algorithm, but these yield $o(\log n)$-round complexity only when the maximum degree $\Delta$ is somewhat small relative to $n$. More importantly, these results apply only in the Local model.  In fact, the best known time bound in the Congest model is still $O(\log n)$ (via Luby&#39;s algorithm) even for somewhat small $\Delta$.  Furthermore, message complexity has been largely ignored in the context of local symmetry breaking. Luby&#39;s algorithm takes $O(m)$ messages on $m$-edge graphs and this is the best known bound with respect to messages. Our work is motivated by the following central question: can we break the $\Theta(m)$ message bound and the $\Theta(\log n)$ time bound in the Congest model for MIS or closely-related symmetry breaking problems?  This paper presents progress towards this question for the distributed ruling set problem in the Congest model.  A $\beta$-ruling set is an independent set such that every node in the graph is at most $\beta$ hops from a node in the independent set. We present the following results: 1. Time Complexity: We show that we can break the $O(\log n)$ ``barrier&#39;&#39; for 2- and 3-ruling sets.  We compute 3-ruling sets in $O\left(\log n/\log \log n\right)$ rounds with high probability (whp).  More generally we show that 2-ruling sets can be computed in $O\left(\log \Delta \cdot (\log n)^{1/2 + \varepsilon} + \log n/\log\log n\right)$ rounds for any $\varepsilon &gt; 0$, which is $o(\log n)$ for a wide range of $\Delta$ values (e.g., $\Delta = 2^{(\log n)^{1/2-\varepsilon}}$).  These are the first 2- and 3-ruling set algorithms to improve over the $O(\log n)$-round complexity of Luby&#39;s algorithm in the Congest model.  2. Message Complexity:  We show an $\Omega(n^2)$ lower bound on the message complexity of computing an MIS (i.e., 1-ruling set) which holds also for randomized algorithms and present a contrast to this by showing a randomized algorithm for 2-ruling sets that, whp, uses  only $O(n \log^2 n)$ messages and runs in $O(\Delta \log n)$ rounds. This is the first message-efficient algorithm known for ruling sets, which takes near-linear message complexity (which is optimal up to a polylogarithmic factor).  Our results are a step toward understanding the  time and message complexity of symmetry breaking problems in the Congest model.</div></li></ul></div><div class="yearContainer"><span class="year">2016</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Fast Distributed Algorithms for Connectivity and MST in Large Graphs</span><a href="http://doi.acm.org/10.1145/2935764.2935785" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Gopal Pandurangan, Peter Robinson, Michele Scquizzato. <span class="publicationInfo">28th ACM Symposium on Parallelism in Algorithms and Architectures</span> (<span class="publicationConfShort">SPAA 2016</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">Motivated by the increasing need to understand the algorithmic foundations of distributed large-scale graph computations, we study a number of fundamental graph problems in a message-passing model for distributed computing where $k \geq 2$ machines jointly perform computations on graphs with $n$ nodes (typically, $n \gg k$).  The input graph is assumed to be initially randomly partitioned among the $k$ machines, a common implementation in many real-world systems. Communication is point-to-point, and the goal is to minimize the number of communication rounds of the computation.  Our main result is an (almost) optimal  distributed randomized algorithm for graph connectivity.  Our algorithm runs in $\tilde{O}(n/k^2)$ rounds ($\tilde{O}$ notation hides a $\text{polylog}(n)$ factor and an additive $\text{polylog}(n)$ term). This improves over the best previously known bound of $\tilde{O}(n/k)$ [Klauck et al., SODA 2015], and is optimal (up to a polylogarithmic factor) in view of an existing lower bound of $\tilde{\Omega}(n/k^2)$. Our improved algorithm uses a bunch of techniques, including linear graph sketching, that prove useful in the design of efficient distributed graph algorithms.  We then present fast randomized algorithms for computing minimum spanning trees, (approximate) min-cuts, and for many graph verification problems. All these algorithms take $\tilde{O}(n/k^2)$ rounds, and are optimal up to polylogarithmic factors.  We also show an almost matching lower bound of $\tilde{\Omega}(n/k^2)$ for many graph verification problems using lower bounds in random-partition communication complexity.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Efficient Computation of Sparse Structures</span><a href="http://onlinelibrary.wiley.com/doi/10.1002/rsa.20653/abstract" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>David G. Harris, Ehab Morsy, Gopal Pandurangan, Peter Robinson, Aravind Srinivasan. <span class="publicationInfo">Random Structures &amp; Algorithms</span> (<span class="publicationConfShort">RSA</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">Basic graph structures such as maximal independent sets (MIS&#39;s)  have spurred much theoretical research in randomized and distributed algorithms, and have several applications in networking and distributed computing as well. However, the extant (distributed) algorithms for these problems do not necessarily guarantee fault-tolerance or load-balance properties. We propose  and study &#39;&#39;low-average degree&#39;&#39; or ``sparse&#39;&#39; versions of such structures. Interestingly, in sharp contrast to, say, MIS&#39;s, it can be shown that checking whether a structure is sparse, will take substantial time. Nevertheless, we are able to develop good  sequential/distributed (randomized) algorithms for such sparse versions.  We also complement our algorithms with several lower bounds. Randomization plays a key role in our upper and lower bound results.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">DEX: Self-Healing Expanders</span><a href="http://dx.doi.org/10.1007/s00446-015-0258-3" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Gopal Pandurangan, Peter Robinson, Amitabh Trehan. <span class="publicationInfo">Distributed Computing</span> (<span class="publicationConfShort">DC</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">We present a fully-distributed self-healing algorithm DEX, that  maintains a  constant degree expander network  in a dynamic setting.  To the best of our knowledge, our algorithm provides  the first  efficient distributed construction of   expanders  --- whose expansion properties  hold deterministically  --- that works even under an all-powerful adaptive adversary that controls the dynamic changes to the network (the adversary has unlimited computational power and knowledge of the  entire network state, can decide which nodes join and leave and at what time, and knows the past random choices made by the algorithm).  Previous distributed expander constructions  typically provide only probabilistic guarantees on the network expansion  which rapidly degrade in a dynamic setting; in particular, the expansion properties can  degrade even more rapidly under  adversarial insertions and deletions.  Our algorithm provides efficient maintenance  and incurs a low overhead per insertion/deletion by an adaptive adversary: only  $O(\log n)$  rounds and $O(\log n)$ messages are needed with high probability  ($n$ is the number of nodes currently in the network). The algorithm requires only a constant number of topology changes.  Moreover, our algorithm allows for an efficient implementation and maintenance of a distributed hash table (DHT) on top of DEX, with only a constant additional overhead. Our results are a step towards implementing  efficient self-healing  networks that have guaranteed properties (constant bounded degree and expansion)   despite  dynamic changes.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Distributed Algorithmic Foundations of Dynamic Networks</span><br>John Augustine, Gopal Pandurangan, Peter Robinson. <span class="publicationInfo">SIGACT News Distributed Computing Column 1/2016</span> (<span class="publicationConfShort">SIGACT</span>). <br></li></ul></div><div class="yearContainer"><span class="year">2015</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Enabling Efficient and Robust Distributed Computation in Highly Dynamic Networks</span><a href="http://dx.doi.org/10.1109/FOCS.2015.29" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>John Augustine, Gopal Pandurangan, Peter Robinson, Scott Roche, Eli Upfal. <span class="publicationInfo">56th Annual IEEE Symposium on Foundations of Computer Science</span> (<span class="publicationConfShort">FOCS 2015</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">Motivated by the need for designing efficient and robust  fully-distributed computation in highly dynamic networks such as Peer-to-Peer (P2P) networks, we study distributed protocols for  constructing and maintaining dynamic network topologies with good expansion properties. Our goal is to maintain a sparse (bounded degree) expander topology  despite heavy churn (i.e., nodes  joining and leaving the network continuously over time).  We assume that the churn is  controlled by an adversary that has  complete knowledge and control of what nodes join and leave and  at what time   and has unlimited computational power, but is oblivious to the random choices made by the algorithm. Our main contribution is a randomized distributed protocol that guarantees  with high probability the maintenance of a constant degree graph with high expansion even under continuous  high adversarial churn. Our protocol can tolerate  a churn rate of up to $O(n/\text{polylog}(n))$ per round (where $n$ is the stable network size).  Our protocol is efficient, lightweight, and scalable, and it  incurs only $O(\text{polylog}(n))$ overhead  for topology maintenance:  only  polylogarithmic  (in $n$)  bits needs to be processed and sent  by each node per round and any node&#39;s computation cost per round is also polylogarithmic. The given protocol is a  fundamental ingredient that is needed for the design of efficient fully-distributed algorithms for solving fundamental distributed computing problems such as agreement,  leader election, search, and storage in highly dynamic P2P networks and enables fast and scalable algorithms for these problems that can tolerate a large amount of churn. </div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">On the Complexity of Universal Leader Election</span><a href="https://www.dropbox.com/s/52u4jwftc9l494b/JACM2015.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://dx.doi.org/10.1145/2699440" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Shay Kutten, Gopal Pandurangan, David Peleg, Peter Robinson, Amitabh Trehan. <span class="publicationInfo">Journal of the ACM, vol. 62(1), 7:1-7:27</span> (<span class="publicationConfShort">JACM</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">Electing a leader is a fundamental task in distributed computing.  In its implicit version, only the leader must know who is the elected leader.  This paper focuses  on studying the message and time complexity of  randomized implicit leader election  in synchronous  distributed networks. Surprisingly, the most &#39;&#39;obvious&#39;&#39; complexity bounds have not been proven for randomized algorithms. The  ``obvious&#39;&#39; lower bounds of $\Omega(m)$ messages ($m$ is the number of edges in the network) and $\Omega(D)$ time  ($D$ is the network diameter) are non-trivial to show for randomized (Monte Carlo) algorithms. (Recent results that show that even $\Omega(n)$ ($n$ is the number of nodes in the network) is  not a lower bound  on the messages in complete networks, make the above  bounds somewhat less obvious).  To the best of our knowledge, these basic lower bounds have not been established even for deterministic algorithms (except for the limited case of comparison algorithms, where it was also required that some nodes may not wake up spontaneously, and that $D$ and $n$ were not known). We establish these fundamental lower bounds in this paper for the general case, even for randomized Monte Carlo algorithms. Our lower bounds are universal in the sense that they hold for all universal algorithms (such algorithms should work for all graphs), apply to  every $D$, $m$, and $n$, and hold even if $D$, $m$, and $n$ are known, all the nodes wake up simultaneously, and the algorithms can make any use of node&#39;s identities.  To show that these bounds are tight, we present an $O(m)$ messages algorithm. An $O(D)$ time algorithm is known. An interesting fundamental problem is whether both upper bounds (messages and time) can be reached simultaneously in the randomized setting for all graphs. (The answer is known to be negative in the deterministic setting).  We answer this problem partially by presenting a randomized algorithm that matches both complexities in some cases.  This already separates (for some cases) randomized algorithms from deterministic ones.  As first steps towards the general case, we present several universal leader election algorithms with bounds that trade-off messages versus time.  We view our results as a step towards understanding the complexity of universal leader election in distributed networks.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Distributed Computation of Large-scale Graph Problems</span><a href="https://www.dropbox.com/s/bgu7ug5kef51375/SODA2015.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://dx.doi.org/10.1137/1.9781611973730.28" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Hartmut Klauck, Danupon Nanongkai, Gopal Pandurangan, Peter Robinson. <span class="publicationInfo">26th ACM-SIAM Symposium on Discrete Algorithms</span> (<span class="publicationConfShort">SODA 2015</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">Motivated by the increasing need for fast distributed processing of  large-scale graphs such as the Web graph and various social networks, we study a number of fundamental  graph problems in the message-passing model, where we have $k$ machines that jointly perform computation on an arbitrary $n$-node (typically, $n \gg k$) input graph. The graph is  assumed to be  randomly  partitioned among the $k  \geq 2$ machines (a common implementation in many real world systems).  The communication is point-to-point, and the goal is to minimize the  time complexity, i.e., the number of communication rounds, of solving various fundamental graph problems.  We present lower bounds that quantify the fundamental time limitations of distributively solving graph  problems.  We first show a lower bound of $\Omega(n/k)$ rounds for  computing a spanning tree (ST) of the input graph. This result also implies the same bound for other fundamental problems such as computing a minimum spanning tree (MST), breadth-first tree (BFS), and shortest paths tree (SPT).    We also show an $\Omega(n/k^2)$ lower bound for connectivity, ST verification and other related problems. Our lower bounds develop and use new bounds in  random-partition communication complexity. To complement our lower bounds, we also  give  algorithms for various fundamental graph problems, e.g., PageRank, MST, connectivity, ST verification, shortest paths, cuts, spanners, covering problems, densest subgraph, subgraph isomorphism, finding triangles, etc. We show that problems such as PageRank, MST,  connectivity, and graph covering  can be solved in $\tilde{O}(n/k)$ time (the notation $\tilde O$ hides $\text{polylog}(n)$ factors and an additive $\text{polylog}(n)$ term); this shows that one can achieve almost linear (in $k$) speedup, whereas for shortest paths, we present  algorithms that run in $\tilde{O}(n/\sqrt{k})$ time (for $(1+\epsilon)$-factor approximation) and in $\tilde{O}(n/k)$ time (for $O(\log n)$-factor approximation) respectively. Our results are a step towards  understanding  the complexity of distributively solving large-scale graph problems.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Fast Byzantine Leader Election in Dynamic Networks</span><br>John Augustine, Gopal Pandurangan, Peter Robinson. <span class="publicationInfo">29th International Symposium on Distributed Computing</span> (<span class="publicationConfShort">DISC 2015</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract"> Motivated by robust, secure, and efficient distributed computation in  Peer-to-Peer (P2P)  networks, we study fundamental Byzantine problems in dynamic networks where the topology  can change from round to round and nodes can also experience heavy churn (i.e., nodes can join and leave the network continuously over time).  We assume the full information model where the Byzantine nodes have complete knowledge about the entire state of network at every round (including random choices made by all the nodes), have unbounded computational power and can deviate arbitrarily from the protocol.  The churn is  controlled by an adversary that has  complete knowledge and control of what nodes join and leave and  at what time  and also may rewire the topology in every round and has unlimited computational power, but is oblivious to the random choices made by the algorithm. Byzantine protocols for fundamental distributed computing problems such as agreement and leader election have been studied extensively for the last three decades in static networks; however, these solutions do not work in dynamic networks which characterize many real-world networks such as P2P networks. Our main contribution is an $O(\log^3 n)$ round algorithm that achieves Byzantine leader election  under the presence of up to $O({n}^{1/2 - \epsilon})$ Byzantine nodes (for a small constant $\epsilon &gt; 0$) and a churn of up to $O(\sqrt{n}/\text{poly}\log(n))$ nodes per round (where $n$ is the stable network size).  The algorithm elects a leader with probability at least $1-n^{-\Omega(1)}$ and guarantees that it is an honest node with probability at least $1-n^{-\Omega(1)}$; assuming the algorithm succeeds, the leader&#39;s identity will be known to a $1-o(1)$ fraction of the honest nodes. Our algorithm is fully-distributed, localized (does not require any global knowledge), lightweight, and is simple to implement. It is also scalable, as it runs in polylogarithmic time and requires nodes to send and receive messages of only polylogarithmic size per round.  To the best of our knowledge, our algorithm is the first scalable solution for Byzantine leader election in a  dynamic network with a high rate of churn; our protocol can also be used to solve Byzantine agreement in a straightforward way.  We also show how to implement an (almost-everywhere) public coin with constant bias in a dynamic network with Byzantine nodes and provide a mechanism for enabling honest nodes to store information reliably in the network, which might be of independent interest.  In decentralized and dynamic P2P systems where a substantial part of the network may be controlled by malicious nodes, the presented algorithm and techniques  can serve as building blocks for designing robust and secure distributed protocols.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Gracefully Degrading Consensus and k-Set Agreement in Directed Dynamic Networks</span><a href="http://dx.doi.org/10.1007/978-3-319-26850-7_8" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Martin Biely, Peter Robinson, Ulrich Schmid, Manfred Schwarz, Kyrill Winkler. <span class="publicationInfo">2nd International Conference on Networked Systems</span> (<span class="publicationConfShort">NETYS 2015</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">We present the first consensus/k-set agreement algorithm for synchronous dynamic networks with unidirectional links, controlled by an omniscient message adversary, which automatically adapts to the actual network properties in a run: If the network is sufficiently well-connected, it solves consensus, while it degrades gracefully to general k-set agreement in less well-connected communication graphs. The actual number k of system-wide decision values is determined by the number of certain vertex-stable root components occurring in a run, which are strongly connected components without incoming links from outside. Related impossibility results reveal that our condition is reasonably close to the solvability border for k-set agreement.</div></li></ul></div><div class="yearContainer"><span class="year">2014</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">DEX: Self-Healing Expanders</span><a href="https://www.dropbox.com/s/2gplsnd7ibzj9fh/IPDPS2014.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://dx.doi.org/10.1109/IPDPS.2014.78" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Gopal Pandurangan, Peter Robinson, Amitabh Trehan. <span class="publicationInfo">28th IEEE International Parallel  Distributed Processing Symposium</span> (<span class="publicationConfShort">IPDPS 2014</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">We present a fully-distributed self-healing algorithm DEX, that  maintains a  constant degree expander network  in a dynamic setting.  To the best of our knowledge, our algorithm provides  the first  efficient distributed construction of   expanders  --- whose expansion properties  hold deterministically  --- that works even under an all-powerful adaptive adversary that controls the dynamic changes to the network (the adversary has unlimited computational power and knowledge of the  entire network state, can decide which nodes join and leave and at what time, and knows the past random choices made by the algorithm).  Previous distributed expander constructions  typically provide only probabilistic guarantees on the network expansion  which rapidly degrade in a dynamic setting; in particular, the expansion properties can  degrade even more rapidly under  adversarial insertions and deletions.  Our algorithm provides efficient maintenance  and incurs a low overhead per insertion/deletion by an adaptive adversary: only  $O(\log n)$  rounds and $O(\log n)$ messages are needed with high probability  ($n$ is the number of nodes currently in the network). The algorithm requires only a constant number of topology changes.  Moreover, our algorithm allows for an efficient implementation and maintenance of a distributed hash table (DHT) on top of DEX, with only a constant additional overhead. Our results are a step towards implementing  efficient self-healing  networks that have guaranteed properties (constant bounded degree and expansion)   despite  dynamic changes.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Distributed Symmetry Breaking in Hypergraphs</span><a href="https://www.dropbox.com/s/5i7iyxfe0f3tsge/DISC2014.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://link.springer.com/chapter/10.1007%2F978-3-662-45174-8_32" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Shay Kutten, Danupon Nanongkai, Gopal Pandurangan, Peter Robinson. <span class="publicationInfo">28th International Symposium on Distributed Computing</span> (<span class="publicationConfShort">DISC 2014</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">Fundamental local symmetry breaking  problems such as Maximal Independent Set (MIS) and coloring have been recognized as important by the community, and studied extensively in (standard) graphs. In particular, fast (i.e., logarithmic run time)   randomized algorithms are well-established for MIS and $\Delta +1$-coloring in both the LOCAL and CONGEST distributed computing models.  On the other hand, comparatively much less is known on the complexity of distributed symmetry breaking in hypergraphs.  In particular,  a key question is  whether a fast (randomized) algorithm for MIS exists  for hypergraphs. In this paper, we study the distributed complexity of symmetry breaking in hypergraphs   by presenting distributed randomized algorithms for a variety of fundamental problems under a natural distributed computing model for hypergraphs.    We first show that MIS in hypergraphs (of arbitrary dimension) can be solved in $O(\log^2 n)$ rounds  ($n$ is the number of nodes of the hypergraph) in the LOCAL  model.  We then present a key result of this paper ---  an $O(\Delta^{\epsilon}\text{poly} \log n)$-round   hypergraph MIS algorithm in the CONGEST model  where  $\Delta$ is the maximum node degree of the hypergraph and $\epsilon &gt; 0$ is any arbitrarily small constant. To demonstrate the usefulness of hypergraph MIS, we present applications of our hypergraph algorithm to solving problems in (standard) graphs.  In particular, the hypergraph MIS yields fast distributed algorithms for the  balanced minimal dominating set problem (left open in Harris et al. [ICALP 2013]) and the minimal connected dominating set  problem.  We also present distributed algorithms for coloring, maximal matching, and maximal clique in hypergraphs. Our work shows that while some local symmetry breaking problems such as coloring can be solved in polylogarithmic rounds in both the LOCAL and CONGEST models, for many other hypergraph problems  such as MIS, hitting set, and maximal clique, it remains challenging to obtain polylogarithmic time algorithms in the CONGEST model.  This work is a step towards understanding this dichotomy in the complexity of hypergraph problems as well as using hypergraphs to design fast distributed algorithms for problems in (standard) graphs.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Sublinear Bounds for Randomized Leader Election</span><a href="https://www.dropbox.com/s/mrjoq806kww3jo1/TCS2014.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://dx.doi.org/10.1016/j.tcs.2014.02.009" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Shay Kutten, Gopal Pandurangan, David Peleg, Peter Robinson, Amitabh Trehan. <span class="publicationInfo">Special Issue of Theoretical Computer Science, Elsevier.</span> (<span class="publicationConfShort">TCS</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">This paper concerns randomized leader election in synchronous distributed networks. A  distributed leader election algorithm  is presented for complete $n$-node networks that  runs in $O(1)$ rounds and (with high probability) uses only $O(\sqrt{n}\log^{3/2} n)$  messages to elect a unique leader (with high probability).  When considering the &#39;&#39;explicit&#39;&#39; variant of leader election where eventually every node knows the identity of the leader, our algorithm yields the asymptotically optimal bounds of $O(1)$ rounds and $O(n)$ messages.  This algorithm is then extended to one solving leader election on any connected non-bipartite $n$-node graph $G$ in $O(\tau(G))$ time and $O(\tau(G)\sqrt{n}\log^{3/2} n)$ messages, where $\tau(G)$ is the mixing time of a random walk on $G$. The above result implies highly efficient (sublinear running time and messages) leader election algorithms for networks with small mixing times, such as expanders and hypercubes.  In contrast, previous  leader election algorithms had at least linear  message complexity even in complete graphs.  Moreover, super-linear message lower bounds are known for time-efficient  deterministic leader election algorithms.  Finally, we present an almost matching lower bound for randomized leader election, showing that $\Omega(\sqrt{n})$ messages are needed for  any leader election algorithm that succeeds with probability at least $1/e + \epsilon$, for any small constant $\epsilon &gt; 0$.  We view our results as a step towards understanding the randomized complexity of leader election in distributed networks. </div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Distributed Agreement in Dynamic Peer-to-Peer Networks</span><a href="https://www.dropbox.com/s/dncy2vxs9kfc7h6/JCSS2015.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://dx.doi.org/10.1016/j.jcss.2014.10.005" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>John Augustine, Gopal Pandurangan, Peter Robinson, Eli Upfal. <span class="publicationInfo">Journal of Computer and System Sciences, Elsevier.</span> (<span class="publicationConfShort">JCSS</span>). <br></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">The Generalized Loneliness Detector and Weak System Models for k-Set Agreement</span><a href="https://www.dropbox.com/s/1t7l5tsyu4g9ktu/TPDS2014.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://dx.doi.org/10.1109/TPDS.2013.77" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Martin Biely, Peter Robinson, Ulrich Schmid. <span class="publicationInfo">IEEE Transactions on Parallel and Distributed Systems, vol. 25(4), 1078-1088</span> (<span class="publicationConfShort">IEEE TPDS</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">This paper presents two weak partially synchronous system models MAnti[n-k] and MSink[n-k], which are just strong enough for solving $k$-set agreement: We introduce the generalized $(n-k)$-loneliness failure detector $\mathcal{L}(k)$, which we first prove to be sufficient for solving $k$-set agreement, and show that $\mathcal{L}(k)$ but not $\mathcal{L}(k-1)$ can be implemented in both models.  MAnti[n-k] and MSink[n-k] are hence the first message passing models that lie between models where $\Omega$ (and therefore consensus) can be implemented and the purely asynchronous model.  We also address $k$-set agreement in anonymous systems, that is, in systems where (unique) process identifiers are not available. Since our novel $k$-set agreement algorithm using $\mathcal{L}(k)$ also works in anonymous systems, it turns out that the loneliness failure detector $\mathcal{L}=\mathcal{L}(n-1)$ introduced by Delporte et al. is also the weakest failure detector for set agreement in anonymous systems. Finally, we analyze the relationship between $\mathcal{L}(k)$ and other failure detectors suitable for solving $k$-set agreement.</div></li></ul></div><div class="yearContainer"><span class="year">2013</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Sublinear Bounds for Randomized Leader Election</span><a href="https://www.dropbox.com/s/ga3wlwlguec5y6e/ICDCN2013.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://link.springer.com/chapter/10.1007/978-3-642-35668-1_24" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Shay Kutten, Gopal Pandurangan, David Peleg, Peter Robinson, Amitabh Trehan. <span class="publicationInfo">14th International Conference on Distributed Computing and Networking</span> (<span class="publicationConfShort">ICDCN 2013</span>). <span class="bestPaper">Best Paper Award.</span><br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">This paper concerns randomized leader election in synchronous distributed networks. A distributed leader election algorithm is presented for complete n-node networks that runs in $O(1)$ rounds and (with high probability) takes only $O(\sqrt{n}\log^{3/2}n)$ messages to elect a unique leader (with high probability). This algorithm is then extended to solve leader election on any connected non-bipartite n-node graph $G$ in $O(\tau(G))$ time and $O(\tau(G)\sqrt{n}\log^{3/2}n)$ messages, where $\tau(G)$ is the mixing time of a random walk on $G$. The above result implies highly efficient (sublinear running time and messages) leader election algorithms for networks with small mixing times, such as expanders and hypercubes. In contrast, previous leader election algorithms had at least linear message complexity even in complete graphs. Moreover, super-linear message lower bounds are known for time-efficient deterministic leader election algorithms. Finally, an almost-tight lower bound is presented for randomized leader election, showing that $\Omega(\sqrt{n})$ messages are needed for any $O(1)$ time leader election algorithm which succeeds with high probability. It is also shown that $\Omega(n^{1/3})$ messages are needed by any leader election algorithm that succeeds with high probability, regardless of the number of the rounds. We view our results as a step towards understanding the randomized complexity of leader election in distributed networks.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Efficient Computation of Balanced Structures</span><a href="https://www.dropbox.com/s/ltewzhayfgy9q7f/ICALP2013.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://dx.doi.org/10.1007/978-3-642-39212-2_51" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>David G. Harris, Ehab Morsy, Gopal Pandurangan, Peter Robinson, Aravind Srinivasan. <span class="publicationInfo">40th International Colloquium on Automata, Languages and Programming</span> (<span class="publicationConfShort">ICALP 2013</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">Basic graph structures such as maximal independent sets (MIS’s) have spurred much theoretical research in distributed algorithms, and have several applications in networking and distributed computing as well.  However, the extant (distributed) algorithms for these problems do not necessarily guarantee fault-tolerance or load-balance properties: For example, in a star-graph, the central vertex, as well as the set of leaves, are both MIS’s, with the latter being much more fault-tolerant and balanced - existing distributed algorithms do not handle this distinction. We propose and study &quot;low-average degree&quot; or &quot;balanced&quot; versions of such structures.  Interestingly, in sharp contrast to, say, MIS’s, it can be shown that checking whether a structure is balanced, will take substantial time.  Nevertheless, we are able to develop good sequential and distributed algorithms for such &quot;balanced&quot; versions. We also complement our algorithms with lower bounds.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">On the Complexity of Universal Leader Election</span><a href="https://www.dropbox.com/s/za9s6wk37j3nm46/PODC2013-2.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://doi.acm.org/10.1145/2484239.2484274" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Shay Kutten, Gopal Pandurangan, David Peleg, Peter Robinson, Amitabh Trehan. <span class="publicationInfo">32nd ACM Symposium on Principles of Distributed Computing</span> (<span class="publicationConfShort">PODC 2013</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">Electing a leader is a fundamental task in distributed computing.  In its implicit version, only the leader must know who is the elected leader.  This paper focuses  on studying the message and time complexity of  randomized implicit leader election  in synchronous  distributed networks. Surprisingly, the most &#39;&#39;obvious&#39;&#39; complexity bounds have not been proven for randomized algorithms. The  ``obvious&#39;&#39; lower bounds of $\Omega(m)$ messages ($m$ is the number of edges in the network) and $\Omega(D)$ time  ($D$ is the network diameter) are non-trivial to show for randomized (Monte Carlo) algorithms. (Recent results that show that even $\Omega(n)$ ($n$ is the number of nodes in the network) is  not a lower bound  on the messages in complete networks, make the above  bounds somewhat less obvious).  To the best of our knowledge, these basic lower bounds have not been established even for deterministic algorithms (except for the limited case of comparison algorithms, where it was also required that some nodes may not wake up spontaneously, and that $D$ and $n$ were not known). We establish these fundamental lower bounds in this paper for the general case, even for randomized Monte Carlo algorithms. Our lower bounds are universal in the sense that they hold for all universal algorithms (such algorithms should work for all graphs), apply to  every $D$, $m$, and $n$, and hold even if $D$, $m$, and $n$ are known, all the nodes wake up simultaneously, and the algorithms can make any use of node&#39;s identities.  To show that these bounds are tight, we present an $O(m)$ messages algorithm. An $O(D)$ time algorithm is known. An interesting fundamental problem is whether  both upper bounds (messages and time) can be reached simultaneously in the randomized setting for all graphs. (The answer is known to be negative in the deterministic setting).  We answer this problem partially by presenting a randomized algorithm that matches both complexities in some cases.  This already separates (for some cases) randomized algorithms from deterministic ones.  As first steps towards the general case, we present several universal leader election algorithms with bounds that trade-off messages versus time.  We view our results as a step towards understanding the complexity of universal leader election in distributed networks.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Fast Byzantine Agreement in Dynamic Networks</span><a href="https://www.dropbox.com/s/grsjk7uwxilm2wz/PODC2013-1.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://doi.acm.org/10.1145/2484239.2484274" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>John Augustine, Gopal Pandurangan, Peter Robinson <span class="publicationInfo">32nd ACM Symposium on Principles of Distributed Computing</span> (<span class="publicationConfShort">PODC 2013</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">We study Byzantine agreement in dynamic networks where topology  can change from round to round and nodes can also experience heavy  churn (i.e., nodes can join and leave the network continuously over time).  Our main contributions are  randomized  distributed algorithms that guarantee   almost-everywhere Byzantine agreement with high probability even under a large number of Byzantine nodes and continuous adversarial churn in a number of rounds that is polylogarithmic in $n$ (where $n$ is the stable network size). We show that our algorithms are essentially optimal (up to polylogarithmic factors)  with respect to the amount of Byzantine nodes and churn rate that they can tolerate by showing lower bound. In particular, we present the following results: \begin{enumerate} \item An $O(\log^3 n)$ round   randomized algorithm that achieves almost-everywhere Byzantine agreement with high probability under a presence of up to $O(\sqrt{n}/\text{polylog}(n))$ Byzantine nodes and up to a churn of $O(\sqrt{n}/\text{polylog}(n))$ nodes per round. We assume that the Byzantine nodes have knowledge about the entire state of network at every round (including random choices made by all the nodes) and can behave arbitrarily. We also assume that an  adversary controls the  churn --- it has  complete knowledge and control of what nodes join and leave and  at what time  and has unlimited computational power (but is oblivious to the topology changes from round to round).  Our algorithm requires only polylogarithmic  in $n$  bits to be processed and sent (per round) by each node.  \item We also present an $O(\log^3 n)$ round randomized algorithm that has same guarantees as the above algorithm, but works even when the churn and network topology is controlled by an adaptive adversary (that can choose the topology based on the current states of the nodes). However, this algorithm requires up to polynomial in $n$ bits to be processed and sent (per round) by each node.  \item We show that the above bounds  are essentially the best possible, if one wants fast (i.e., polylogarithmic run time)  algorithms, by showing that  any (randomized) algorithm to achieve   agreement in a dynamic network controlled by an adversary  that can churn up to $\Theta(\sqrt{ n \log n})$ nodes per round should take at least a  polynomial number of rounds.  \end{enumerate} Our algorithms are the first-known, fully-distributed, Byzantine agreement algorithms in highly dynamic networks.  We view our results as a step towards understanding the possibilities and limitations of highly dynamic networks that are subject to malicious behavior by a large number of nodes.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Search and Storage in Dynamic Peer-to-Peer Networks</span><a href="https://www.dropbox.com/s/1ffcepq8a20wmmi/SPAA2013.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://doi.acm.org/10.1145/2486159.2486170" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>John Augustine, Anisur Molla, Ehab Morsy, Gopal Pandurangan, Peter Robinson, Eli Upfal. <span class="publicationInfo">25th ACM Symposium on Parallelism in Algorithms and Architectures</span> (<span class="publicationConfShort">SPAA 2013</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">We study robust and efficient  distributed algorithms for searching, storing, and maintaining data  in dynamic Peer-to-Peer (P2P) networks. P2P networks  are  highly dynamic networks  that experience heavy node churn (i.e., nodes  join and leave the network continuously over time). Our goal  is to guarantee, despite high node churn rate,  that a large number of nodes in the network can  store, retrieve, and maintain a large number of data items.  Our main contributions are fast randomized  distributed algorithms  that guarantee the above  with high probability even under high adversarial churn.   In particular, we present the following main results: \begin{enumerate} \item  A  randomized distributed search algorithm that with high probability guarantees that  searches from as many as $n - o(n)$ nodes  ($n$ is the stable network size) succeed in ${O}(\log n )$-rounds despite ${O}(n/\log^{1+\delta} n)$ churn, for any  small constant $\delta &gt; 0$,  per round.  We assume that the churn is controlled by an oblivious adversary (that has  complete knowledge and control of what nodes join and leave and  at what time  and has unlimited computational power, but is oblivious to the random choices made by the algorithm).   \item  A storage and maintenance algorithm that guarantees, with high probability,   data items  can be  efficiently stored (with only $\Theta(\log{n})$ copies of each data item) and maintained in a dynamic P2P network with churn rate up to ${O}(n/\log^{1+\delta} n)$ per round.  Our search algorithm together with  our storage and maintenance algorithm guarantees that as many as $n - o(n)$ nodes can efficiently store, maintain, and search  even under ${O}(n/\log^{1+\delta} n)$ churn  per round. Our  algorithms require only polylogarithmic  in $n$  bits to be processed and sent (per round) by each node.  \end{enumerate} To the best of our knowledge, our algorithms are the first-known, fully-distributed storage and search algorithms that provably work under highly dynamic settings (i.e., high churn rates per step).  Furthermore, they are  localized (i.e., do not require any global topological knowledge) and scalable.  A technical contribution of this paper, which may be of independent interest, is  showing how random walks can be provably used to derive scalable distributed algorithms in dynamic networks with adversarial node churn.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Robust Leader Election in a Fast-Changing World</span><br>John Augustine, Tejas Kulkarni, Paresh Nakhe, Peter Robinson. <span class="publicationInfo">9th International Workshop on Foundations of Mobile Computing</span> (<span class="publicationConfShort">FOMC 2013</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">We consider the problem of electing a leader among nodes in a highly dynamic network where the adversary has unbounded capacity to insert and remove nodes (including the leader) from the network and change connectivity at will.  We present a randomized algorithm that (re)elects a leader in $O(D\log n)$ rounds with high probability, where $D$ is a bound on the dynamic diameter of the network and $n$ is the maximum number of nodes in the network at any point in time.  We assume a model of broadcast-based communication where a node can send only $1$ message of $O(\log n)$ bits per round and is not aware of the receivers in advance.  Thus our results also apply to mobile wireless ad-hoc networks, improving over the optimal (for deterministic algorithms) $O(Dn)$ solution presented at FOMC 2011. We show that our algorithm is optimal by  proving that  any randomized algorithm takes at least $\Omega(D\log n)$ rounds to elect a leader with high probability, which shows that our algorithm yields the best possible (up to constants) termination time.</div></li></ul></div><div class="yearContainer"><span class="year">2012</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Towards Robust and Efficient Computation in Dynamic Peer-to-Peer Networks</span><a href="https://www.dropbox.com/s/7dkyl2ow32qkll3/SODA2012.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://portal.acm.org/citation.cfm?id=2095163&amp;CFID=63838676&amp;CFTOKEN=79617016" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>John Augustine, Gopal Pandurangan, Peter Robinson, Eli Upfal. <span class="publicationInfo">23rd ACM-SIAM Symposium on Discrete Algorithms</span> (<span class="publicationConfShort">SODA 2012</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">Motivated by the need for robust and fast distributed computation in highly dynamic Peer-to-Peer (P2P) networks, we study algorithms for  the fundamental  distributed agreement problem.   P2P networks  are  highly dynamic networks  that experience heavy node churn (i.e., nodes  join and leave the network continuously over time). Our goal  is to design fast  algorithms (running in a small number of rounds) that guarantee, despite high node churn rate,  that almost all nodes   reach a stable agreement.  Our main contributions are randomized  distributed algorithms that guarantee   stable almost-everywhere agreement with high probability even under high adversarial churn in a polylogarithmic number of rounds.  In particular, we present the following results: \begin{enumerate} \item An $O(\log^2 n)$-round  ($n$ is the stable network size) randomized algorithm that achieves almost-everywhere agreement with high probability under up to linear churn  per round (i.e., $\epsilon n$, for some small constant $\epsilon &gt; 0$), assuming that the churn is controlled by an oblivious adversary (that has  complete knowledge and control of what nodes join and leave and  at what time  and has unlimited computational power, but is oblivious to the random choices made by the algorithm).  \item An $O(\log m\log^3 n)$-round randomized algorithm that achieves almost-everywhere agreement with high probability under up to $\epsilon \sqrt{n}$ churn  per round (for some small $\epsilon &gt; 0$), where $m$ is the size of the input value domain, that works even under an adaptive adversary (that also knows the past random choices made by the algorithm). \item We also show that no deterministic algorithm can guarantee almost-everywhere agreement (regardless of the number of rounds), even under constant churn rate.  \end{enumerate} Our algorithms are the first-known, fully-distributed,  agreement algorithms that work under highly dynamic settings (i.e., high churn rates per step).  Furthermore, they are  localized (i.e., do not require any global topological knowledge), simple, and easy to implement.  These algorithms can serve as building blocks for implementing other non-trivial distributed computing tasks in dynamic P2P networks.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Agreement in Directed Dynamic Networks</span><a href="https://www.dropbox.com/s/0rx40khhv6qax81/SIROCCO2012.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://dx.doi.org/10.1007/978-3-642-31104-8_7" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Martin Biely, Peter Robinson, Ulrich Schmid. <span class="publicationInfo">19th International Colloquium on Structural Information and Communication Complexity</span> (<span class="publicationConfShort">SIROCCO 2012</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">We study distributed computation in synchronous dynamic networks where an omniscient adversary controls the unidirectional communication links. Its behavior is modeled as a sequence of directed graphs representing the active (i.e. timely) communication links per round.  We prove that consensus is impossible under some natural weak connectivity assumptions and introduce vertex-stable root components as a means for circumventing this impossibility.  Essentially, we assume that there is a short period of time during which an arbitrary part of the network remains strongly connected, while its interconnect topology may keep changing continuously.  We present a consensus algorithm that works under this assumption and prove its correctness. Our algorithm maintains a local estimate of the communication graphs and applies techniques for detecting stable network properties and univalent system configurations.  Our possibility results are complemented by several impossibility results and lower bounds for consensus and other distributed computing problems like leader election, revealing that our algorithm is asymptotically optimal.</div></li></ul></div><div class="yearContainer"><span class="year">2011</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Weak System Models for Fault-Tolerant Distributed Agreement Problems</span><br>Peter Robinson. <span class="publicationInfo">PhD Thesis in Computer Science.</span><br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">This thesis investigates various aspects of weak system models for agreement problems in fault-tolerant distributed computing.  In Part~I we provide an introduction to the context of this work, discuss related literature and describe the basic system assumptions. In Part~II of this thesis, we introduce the Asynchronous Bounded-Cycle (ABC) model, which is entirely time-free.  In contrast to existing system models, the ABC model does not require explicit time-based synchrony bounds, but rather stipulates a graph-theoretic synchrony condition on the relative lengths of certain causal chains of messages in the space-time graph of a run.  We compare the ABC model to other models in literature, in particular to the classic models by Dwork, Lynch, and Stockmeyer.  Despite Byzantine failures, we show how to simulate lock-step rounds, and therefore make consensus solvable, and prove the correctness of a clock synchronization algorithm in the ABC model.  We then present the technically most involved result of this thesis: We prove that any algorithm working correctly in the partially synchronous $\Theta$-Model by Le Lann and Schmid, also works correctly in the time-free ABC model.  In the proof, we use a variant of Farkas&#39; Theorem of Linear Inequalities and develop a non-standard cycle space on directed graphs in order to guarantee the existence of a certain message delay transformation for finite prefixes of runs.  This shows that any time-free safety property satisfied by an algorithm in the $\Theta$-Model also holds in the ABC model.  By employing methods from point-set topology, we can extend this result to liveness properties. In Part~III, we shift our attention to the borderland between models where consensus is solvable and the purely asynchronous model.  To this end, we look at the $k$-set agreement problem where processes need to decide on at most $k$ distinct decision values.  We introduce two very weak system models MAnti and MSink and prove that consensus is impossible in these models.  Nevertheless, we show that $(n-1)$-set agreement is solvable in MAnti and MSink, by providing algorithms that implement the weakest failure detector $\mathcal{L}$.  We also discuss how models MAnti and MSink relate to the $f$-source models by Aguilera et al. for solving consensus. In the subsequent chapter, we present a novel failure detector $\mathcal{L}(k)$ that generalizes $\mathcal{L}$, and analyze an algorithm for solving $k$-set agreement with $\mathcal{L}(k)$, which works even in systems without unique process identifiers.  Moreover, We explore  the relationship between $\mathcal{L}(k)$ and existing failure detectors for $k$-set agreement.  Some aspects of $\mathcal{L}(k)$ relating to anonymous systems  are also discussed. Next, we present a generic theorem that can be used to characterize the impossibility of achieving $k$-set agreement in various system models.  This enables us to show that $(\Sigma_k,\Omega_k)$ is not sufficient for solving $k$-set agreement.  Furthermore, we instantiate our theorem with a partially synchronous system model. Finally, we consider the $k$-set agreement problem in round-based systems.  First, we introduce a novel abstraction that encapsulates the perpetual synchrony of a run, the so called stable skeleton graph, which allows us to express the solvability power of a system via graph-theoretic properties.  We then present an approximation algorithm where processes output an estimate of their respective component of the stable skeleton graph.  We define a class of communication predicates PSources(k) in this framework, and show that PSources(k) tightly captures the amount of synchrony necessary for $k$-set agreement, as $(k-1)$-set agreement is impossible with PSources(k).  Based on the stable skeleton approximation, we present an algorithm that solves $k$-set agreement when PSources(k) holds.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Optimal Regional Consecutive Leader Election in Mobile Ad-Hoc Networks</span><a href="https://www.dropbox.com/s/tgv0lew3u6k2xdy/FOMC2011.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://dl.acm.org/authorize?431055" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Hyun Chul Chung, Peter Robinson, Jennifer L. Welch. <span class="publicationInfo">7th ACM SIGACT/SIGMOBILE International Workshop on Foundations of Mobile Computing</span> (<span class="publicationConfShort">part of FCRC 2011</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">The regional consecutive leader election (RCLE) problem requires mobile nodes to elect a leader within bounded time upon entering a specific region.  We prove that any algorithm requires $\Omega(Dn)$ rounds for leader election, where D is the diameter of the network and $n$ is the total number of nodes.  We then present a fault-tolerant distributed algorithm that solves the RCLE problem and works even in settings where nodes do not have access to synchronized clocks.  Since nodes set their leader variable within $O(Dn)$ rounds, our algorithm is asymptotically optimal with respect to time complexity.  Due to its low message bit complexity, we believe that our algorithm is of practical interest for mobile wireless ad-hoc networks.  Finally, we present a novel and intuitive constraint on mobility that guarantees a bounded communication diameter among nodes within the region of interest.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Solving k-Set Agreement with Stable Skeleton Graphs</span><a href="https://www.dropbox.com/s/hbbujihq03pob1s/IPDPS2011.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://doi.ieeecomputersociety.org/10.1109/IPDPS.2011.301" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Martin Biely, Peter Robinson, Ulrich Schmid. <span class="publicationInfo">16th IEEE International Symposium on Parallel and Distributed Processing Workshops and PhD Forum</span> (<span class="publicationConfShort">IPDPS 2011</span>). <br></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Easy Impossibility Proofs for k-Set Agreement in Message Passing Systems</span><a href="OPODIS 201://www.dropbox.com/s/ohur8g25xz858z3/OPODIS2011.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://dx.doi.org/10.1007/978-3-642-25873-2_21" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Martin Biely, Peter Robinson, Ulrich Schmid. <span class="publicationInfo">15th International Conference On Principles Of Distributed Systems</span> (<span class="publicationConfShort">OPODIS 2011</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">Despite of being quite similar agreement problems, distributed consensus ($1$-set agreement) and general $k$-set agreement require surprisingly different techniques for proving their impossibility in asynchronous systems with crash failures: Rather, than the relatively simple bivalence arguments as in the impossibility proof for consensus in the presence of a single crash failure, known proofs for the impossibility of $k$-set agreement in shared memory systems with $f\geq k&gt;1$ crash failures use algebraic topology or a variant of Sperner&#39;s Lemma. In this paper, we present a generic theorem for proving the impossibility of $k$-set agreement in various message passing settings, which is based on a reduction to the consensus impossibility in a certain subsystem resulting from a partitioning argument. We demonstrate the broad applicability of our result by exploring the possibility/impossibility border of $k$-set agreement in several message passing system models: (i) asynchronous systems with crash failures, (ii) partially synchronous processes with (initial) crash failures, and, most importantly, (iii) asynchronous systems augmented with failure detectors.  Furthermore, by extending the algorithm for initial crashes of Fisher, Lynch and Patterson (1985) to general $k$-set agreement, we show that the impossibility border of (i) is tightly matched. The impossibility proofs in cases (i), (ii), and (iii) are instantiations of our main theorem. Regarding (iii), applying our technique reveals the exact border for the parameter $k$ where $k$-set agreement is solvable with the failure detector class $(\Sigma_k,\Omega_k)_{1\le k\le n-1}$ of Bonnet and Raynal.  As $\Sigma_k$ was shown to be necessary for solving $k$-set agreement, this result yields new insights on the quest for the weakest failure detector</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">The Asynchronous Bounded-Cycle Model</span><a href="https://www.dropbox.com/s/56tr3r6dgq7e4i2/TCS2011.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://dx.doi.org/10.1016/j.tcs.2010.08.001" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Peter Robinson and Ulrich Schmid. <span class="publicationInfo">Theoretical Computer Science 412 (2011) 5580–5601.</span> (<span class="publicationConfShort">TCS</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">This paper shows how synchrony conditions can be added to the purely asynchronous model in a way that avoids any reference to message delays and computing step times, as well as any global constraints on communication patterns and network topology. Our Asynchronous Bounded-Cycle (ABC) model just bounds the ratio of the number of forward- and backward-oriented messages in certain &#39;&#39;relevant&#39;&#39; cycles in the space-time diagram of an asynchronous execution.  We show that clock synchronization and lock-step rounds can easily be implemented and proved correct in the ABC model, even in the presence of Byzantine failures.  Furthermore, we prove that any algorithm working correctly in the partially synchronous $\Theta$-Model also works correctly in the ABC model. In our proof, we first apply a novel method for assigning certain message delays to asynchronous executions, which is based on a variant of Farkas&#39; theorem of linear inequalities and a non-standard cycle-space of graphs. Using methods from point-set topology, we then prove that the existence of this delay assignment implies model indistinguishability for time-free safety and liveness properties.  Finally, we introduce several weaker variants of the ABC model and relate our model to the existing partially synchronous system models, in particular, the classic models of Dwork, Lynch and Stockmayer. Furthermore, we discuss aspects of the ABC model&#39;s applicability in real systems, in particular, in the context of VLSI Systems-on-Chip.</div></li></ul></div><div class="yearContainer"><span class="year">2010</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Regional Consecutive Leader Election in Mobile Ad-Hoc Networks</span><br>Hyun Chul Chung, Peter Robinson, Jennifer L. Welch. <span class="publicationInfo">6th ACM SIGACT/SIGMOBILE Workshop on Foundations of Mobile Computing</span> (<span class="publicationConfShort">DIALM-POMC 2010</span>). <br></li></ul></div><div class="yearContainer"><span class="year">2009</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Weak Synchrony Models and Failure Detectors for Message Passing k-Set Agreement</span><a href="http://www.springerlink.com/content/530741614w724416/" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Martin Biely, Peter Robinson, Ulrich Schmid. <span class="publicationInfo">13th International Conference On Principles Of Distributed Systems</span> (<span class="publicationConfShort">OPODIS 2009</span>). <br></li></ul></div><div class="yearContainer"><span class="year">2008</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">The Asynchronous Bounded-Cycle Model</span><a href="http://dx.doi.org/10.1007/978-3-540-89335-6_20" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Peter Robinson and Ulrich Schmid. <span class="publicationInfo">10th International Symposium on Stabilization, Safety, and Security of Distributed Systems</span> (<span class="publicationConfShort">SSS 2008</span>). <span class="bestPaper">Best Paper Award.</span><br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">This paper shows how synchrony conditions can be added to the purely asynchronous model in a way that avoids any reference to message delays and computing step times, as well as any global constraints on communication patterns and network topology. Our Asynchronous Bounded-Cycle (ABC) model just bounds the ratio of the number of forward- and backward-oriented messages in certain &#39;&#39;relevant&#39;&#39; cycles in the space-time diagram of an asynchronous execution.  We show that clock synchronization and lock-step rounds can easily be implemented and proved correct in the ABC model, even in the presence of Byzantine failures.  Furthermore, we prove that any algorithm working correctly in the partially synchronous $\Theta$-Model also works correctly in the ABC model. In our proof, we first apply a novel method for assigning certain message delays to asynchronous executions, which is based on a variant of Farkas&#39; theorem of linear inequalities and a non-standard cycle-space of graphs. Using methods from point-set topology, we then prove that the existence of this delay assignment implies model indistinguishability for time-free safety and liveness properties.  Finally, we introduce several weaker variants of the ABC model and relate our model to the existing partially synchronous system models, in particular, the classic models of Dwork, Lynch and Stockmayer. Furthermore, we discuss aspects of the ABC model&#39;s applicability in real systems, in particular, in the context of VLSI Systems-on-Chip.</div></li></ul></div><div class="yearContainer"><span class="year">2006</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Log File Processing by Machine Learning and Information Extraction</span><br>Peter Robinson. <span class="publicationInfo">Master Thesis. TU Vienna, Institute of Computer Languages, 2006. Nominated for Distinguished Young Alumnus Award.</span><br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">In today&#39;s computer network systems lots of events are constantly written to log files.  Unfortunately there is no common standard defining the structure of these event messages which are partly in human readable natural language form. This lack of structure makes automatic processing a lot more difficult.  This master thesis describes the architecture and implementation of the LoP-System, a system that             attempts to create machine readable event structures from ordinary log file events by natural language processing.  The thesis explains implementational details as well as the theoretical concepts used. The core of the system consists of a series of cascaded but independent components, partly enhanced with machine learning techniques.  The raw input is first processed by a simple recursive descent parser which recognizes syntactical features (e.g. IP addresses) and is then passed on to a part-of-speech tagger based on a hidden Markov model.  Applying regular expression patterns to the tagged words is used to combine them to basic word groups (e.g. noun groups), which are subsequently semantically analyzed.  The final step is the construction of the output events by a rule based event constructor. All components are implemented in Haskell, a purely functional programming language.  Some of the components developed during this thesis, especially the part-of-speech tagger, are general natural language processing tools and can be applied to other domains.</div></li></ul></div></div><div class="intro revealOnScroll"><h2><a class="anchor" id="Code">Code</a></h2><div>I&#39;m interested in parallel and distributed programming and related technologies such as software transactional memory and the actor-model. Recently, I have been working on implementing a simulation environment for distributed algorithms in Elixir/Erlang, and implementing non-blocking data structures in Haskell suitable for multi-core machines. Below is a (non-comprehensive) list of software that I have written. </div><ul class="longList fa-ul"><li><i class="fa fa-li fa-caret-right"></i><a class="external" href="http://hackage.haskell.org/package/concurrent-hashtable">concurrent hash table:</a> a thread-safe hash table that scales to multicores.</li><li><i class="fa fa-li fa-caret-right"></i><a class="external" href="http://hackage.haskell.org/package/data-dispersal">data dispersal:</a> an implementation of an (m,n)-threshold information dispersal scheme that is space-optimal.</li><li><i class="fa fa-li fa-caret-right"></i><a class="external" href="http://hackage.haskell.org/package/secret-sharing">secret sharing:</a> an implementation of a secret sharing scheme that provides information-theoretic security.</li><li><i class="fa fa-li fa-caret-right"></i><a class="external" href="http://hackage.haskell.org/package/tskiplist">tskiplist:</a> a data structure with range-query support for software transactional memory.</li><li><i class="fa fa-li fa-caret-right"></i><a class="external" href="http://hackage.haskell.org/package/stm-io-hooks">stm-io-hooks:</a> An extension of Haskell&#39;s Software Transactional Memory (STM) monad with commit and retry IO hooks.</li><li><i class="fa fa-li fa-caret-right"></i><a class="external" href="http://hackage.haskell.org/package/mathgenealogy">Mathgenealogy:</a> Visualize your (academic) genealogy! A program for extracting data from the Mathematics Genealogy project.</li><li><i class="fa fa-li fa-caret-right"></i>I extended Haskell&#39;s <a class="external" href="https://www.haskell.org/cabal/">Cabal,</a> for using a &quot;world&quot; file to keep track of installed packages.  (Now part of the main distribution.)</li></ul></div><div class="intro revealOnScroll" id="teaching"><h2><a class="anchor" id="Teaching">Teaching</a></h2><ul class="longList fa-ul"><li><i class="fa fa-li fa-caret-right"></i>Database Systems, Spring 2020.</li><li><i class="fa fa-li fa-caret-right"></i>Computer Networks, Fall 2019.</li><li><i class="fa fa-li fa-caret-right"></i>Distributed Computing, Spring 2019.</li><li><i class="fa fa-li fa-caret-right"></i>Randomized Algorithms, Fall 2018: <a class="external" href="https://www.cas.mcmaster.ca/robinson/teaching/cas781/intro_slides/">Intro slides. </a><a class="external" href="https://www.cas.mcmaster.ca/robinson/teaching/cas781/markov/">Part 1 on Concentration Bounds.</a></li><li><i class="fa fa-li fa-caret-right"></i>Advanced Distributed Systems, Fall 2016, 2017.</li><li><i class="fa fa-li fa-caret-right"></i>Computation with Data, Fall 2016.</li><li><i class="fa fa-li fa-caret-right"></i>Internet and Web Technologies, Spring 2016.</li></ul></div><div class="intro revealOnScroll" id="misc"><h2><a class="anchor" id="Misc">Misc</a></h2><ul class="longList fa-ul"><li><i class="fa fa-li fa-caret-right"></i>Google scholar <a class="external" href="http://scholar.google.com.sg/citations?user=DsPjnMQAAAAJ&amp;hl=en">profile</a></li><li><i class="fa fa-li fa-caret-right"></i>My profile on <a class="external" href="http://stackexchange.com/users/555378/monoid">StackExchange</a></li></ul></div></div></div></div></body></html>