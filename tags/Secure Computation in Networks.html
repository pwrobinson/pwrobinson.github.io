<!DOCTYPE HTML>
<html><head><link href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" rel="stylesheet"><link href="https://pwrobinson.github.io/style1.css" rel="stylesheet"><link href="https://pwrobinson.github.io/style2.css" rel="stylesheet"><script type="text/javascript">document.documentElement.className = document.documentElement.className.replace(/no-js/,'js');</script><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script src="jquery.waypoints.min.js"></script><script src="jquery.isonscreen.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script><script type="text/javascript" async="true" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML"></script><script type="text/javascript" src="https://pwrobinson.github.io/script.js"></script><style type="text/css">.MathJax_Preview {color: #888} #MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap} #MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px} .MathJax_Error {color: #CC0000; font-style: italic}</style></head><body><div class="outerContainer"><div id="main"><div id="top_container"><div id="header"><div id="header_container"><div id="address"><h2 id="myname">Peter Robinson</h2><p class="email"><a href="mailto:peter.robinson(at)cityu(dot)edu(dot)hk">peter dot robinson at cityu dot edu dot hk</a></p></div><div id="mypic"><img id="myimg" src="pic.jpg" alt="" width="156" height="204"></div></div><ul id="nav"><li><a class="navLink" id="about" href="#About">About</a></li><li><a class="navLink" id="publications" href="#Publications">Publications</a></li><li><a class="navLink" id="code" href="#Code">Code</a></li><li><a class="navLink" id="teaching" href="#Teaching">Teaching</a></li><li><a class="navLink" id="misc" href="#Misc">Misc</a></li></ul></div></div><div class="mycontainer" class="anchor" id="About"><div class="intro"><p>I&#39;m an Assistant Professor in the Computer Science Department of the City University of Hong Kong. My research focuses on designing new distributed and parallel algorithms, the distributed processing of big data, achieving fault-tolerance in communication networks against adversarial attacks, and developing robust protocols that work in highly dynamic environments such as peer-to-peer Blockchain networks and mobile ad-hoc networks.</p><p>My research has been supported by the General Research Fund (Hong Kong), the Natural Sciences and Engineering Research Council (Canada), IBM Research, and the London Mathematical Society.</p></div><div class="intro"><h2>News</h2><ul id="newsList" class="fa-ul"><li><i class="fa fa-li fa-caret-right"></i>New papers at SODA 2021 and PODC 2021</li><li><i class="fa fa-li fa-caret-right"></i>General Chair of ACM PODC 2019</li><li><i class="fa fa-li fa-caret-right"></i>On program committee of <a href="http://www.disc-conference.org/wp/">DISC 2021</a>, <a href="https://icdcs2021.us/">ICDCS 2021</a>, <a href="https://sirocco2021.ii.uni.wroc.pl/">SIROCCO 2021</a>, <a href="http://www.podc.org">PODC 2020</a></li></ul></div><div class="tagCloud"><h2 class="tagCloud">Tags <a href="../index.html">(Show all)</a></h2><a class="keyword" style="font-size: 1.4924572em" href="https://pwrobinson.github.io//tags/Asynchrony.html#Publications"> Asynchrony  </a><a class="keyword" style="font-size: 1.2em" href="https://pwrobinson.github.io//tags/Big Data.html#Publications"> Big Data  </a><a class="keyword" style="font-size: 1.2em" href="https://pwrobinson.github.io//tags/Byzantine Failures.html#Publications"> Byzantine Failures  </a><a class="keyword" style="font-size: 1.2em" href="https://pwrobinson.github.io//tags/Churn.html#Publications"> Churn  </a><a class="keyword" style="font-size: 1.2em" href="https://pwrobinson.github.io//tags/Communication Complexity.html#Publications"> Communication Complexity  </a><a class="keyword" style="font-size: 1.8394337em" href="https://pwrobinson.github.io//tags/Distributed Agreement.html#Publications"> Distributed Agreement  </a><a class="keyword" style="font-size: 1.2em" href="https://pwrobinson.github.io//tags/Distributed Storage.html#Publications"> Distributed Storage  </a><a class="keyword" style="font-size: 1.7422329em" href="https://pwrobinson.github.io//tags/Dynamic Network.html#Publications"> Dynamic Network  </a><a class="keyword" style="font-size: 2.0em" href="https://pwrobinson.github.io//tags/Fault-Tolerance.html#Publications"> Fault-Tolerance  </a><a class="keyword" style="font-size: 1.2em" href="https://pwrobinson.github.io//tags/Gossip Communication.html#Publications"> Gossip Communication  </a><a class="keyword" style="font-size: 1.8832712em" href="https://pwrobinson.github.io//tags/Graph Algorithm.html#Publications"> Graph Algorithm  </a><a class="keyword" style="font-size: 1.2em" href="https://pwrobinson.github.io//tags/Haskell.html#Publications"> Haskell  </a><a class="keyword" style="font-size: 1.2em" href="https://pwrobinson.github.io//tags/Information Complexity.html#Publications"> Information Complexity  </a><a class="keyword" style="font-size: 1.5640229em" href="https://pwrobinson.github.io//tags/Leader Election.html#Publications"> Leader Election  </a><a class="keyword" style="font-size: 1.2em" href="https://pwrobinson.github.io//tags/Machine Learning.html#Publications"> Machine Learning  </a><a class="keyword" style="font-size: 1.2em" href="https://pwrobinson.github.io//tags/Mobile Ad-Hoc Network.html#Publications"> Mobile Ad-Hoc Network  </a><a class="keyword" style="font-size: 1.2em" href="https://pwrobinson.github.io//tags/Natural Language Processing.html#Publications"> Natural Language Processing  </a><a class="keyword" style="font-size: 1.4924572em" href="https://pwrobinson.github.io//tags/P2P.html#Publications"> P2P  </a><a class="keyword" style="font-size: 1.5640229em; color:red;" href="https://pwrobinson.github.io//tags/Secure Computation in Networks.html#Publications">Secure Computation in Networks</a><a class="keyword" style="font-size: 1.2em" href="https://pwrobinson.github.io//tags/Self-Healing.html#Publications"> Self-Healing  </a><a class="keyword" style="font-size: 1.4124534em" href="https://pwrobinson.github.io//tags/Symmetry Breaking.html#Publications"> Symmetry Breaking  </a><a class="keyword" style="font-size: 1.2em" href="https://pwrobinson.github.io//tags/Wireless Networks.html#Publications"> Wireless Networks  </a></div><h2><a class="anchor" id="Publications">Publications</a></h2><div class="publicationList"><div class="yearContainer"><span class="year">2018</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Breaking the $\Omega(\sqrt{n})$ Barrier: Fast Consensus under a Late Adversary</span><a href="http://doi.acm.org/10.1145/3210377.3210399" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Peter Robinson, Christian Scheideler, Alexander Setzer. <span class="publicationInfo">30th ACM Symposium on Parallelism in Algorithms and Architectures.</span> (<span class="publicationConfShort">SPAA 2018</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">We study the consensus problem in a synchronous distributed system of $n$ nodes under an adaptive adversary that has a slightly outdated view of the system and can block all incoming and outgoing communication of a constant fraction of the nodes in each round.  Motivated by a result of Ben-Or and Bar-Joseph (1998), showing that any consensus algorithm that is resilient against a linear number of crash faults requires $\tilde \Omega(\sqrt{n})$ rounds in an $n$-node network against an adaptive adversary, we consider a late adaptive adversary, who has full knowledge of the network state at the beginning of the previous round and unlimited computational power, but is oblivious to the current state of the nodes.  Our main contributions are randomized distributed algorithms that achieve consensus with high probability among all except a small constant fraction of the nodes (i.e., ``almost-everywhere&#39;&#39;) against a late adaptive adversary who can block up to $\epsilon n$ nodes in each round, for a small constant $\epsilon &gt;0$.  Our first protocol achieves binary almost-everywhere consensus and also guarantees a decision on the majority input value, thus ensuring plurality consensus.  We also present an algorithm that achieves the same time complexity for multi-value consensus.  Both of our algorithms succeed in $O(\log n)$ rounds with high probability, thus breaking the known $\tilde\Omega(\sqrt{n})$ lower bound for fully adaptive  adversaries.  Our algorithms are scalable to large systems as each node contacts only an (amortized) constant number of peers in each communication round.  We show that our algorithms are optimal up to constant (resp. sub-logarithmic) factors by proving that every almost-everywhere consensus protocol takes $\Omega(\log_d n)$ rounds in the worst case, where $d$ is an upper bound on the number of communication requests initiated per node in each round.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Gracefully Degrading Consensus and k-Set Agreement in Directed Dynamic Networks</span><br>Martin Biely, Peter Robinson, Ulrich Schmid, Manfred Schwarz, Kyrill Winkler. <span class="publicationInfo">Theoretical Computer Science 726: 41-77 (2018)</span> (<span class="publicationConfShort">TCS</span>). <br></li></ul></div><div class="yearContainer"><span class="year">2015</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Fast Byzantine Leader Election in Dynamic Networks</span><br>John Augustine, Gopal Pandurangan, Peter Robinson. <span class="publicationInfo">29th International Symposium on Distributed Computing</span> (<span class="publicationConfShort">DISC 2015</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract"> Motivated by robust, secure, and efficient distributed computation in  Peer-to-Peer (P2P)  networks, we study fundamental Byzantine problems in dynamic networks where the topology  can change from round to round and nodes can also experience heavy churn (i.e., nodes can join and leave the network continuously over time).  We assume the full information model where the Byzantine nodes have complete knowledge about the entire state of network at every round (including random choices made by all the nodes), have unbounded computational power and can deviate arbitrarily from the protocol.  The churn is  controlled by an adversary that has  complete knowledge and control of what nodes join and leave and  at what time  and also may rewire the topology in every round and has unlimited computational power, but is oblivious to the random choices made by the algorithm. Byzantine protocols for fundamental distributed computing problems such as agreement and leader election have been studied extensively for the last three decades in static networks; however, these solutions do not work in dynamic networks which characterize many real-world networks such as P2P networks. Our main contribution is an $O(\log^3 n)$ round algorithm that achieves Byzantine leader election  under the presence of up to $O({n}^{1/2 - \epsilon})$ Byzantine nodes (for a small constant $\epsilon &gt; 0$) and a churn of up to $O(\sqrt{n}/\text{poly}\log(n))$ nodes per round (where $n$ is the stable network size).  The algorithm elects a leader with probability at least $1-n^{-\Omega(1)}$ and guarantees that it is an honest node with probability at least $1-n^{-\Omega(1)}$; assuming the algorithm succeeds, the leader&#39;s identity will be known to a $1-o(1)$ fraction of the honest nodes. Our algorithm is fully-distributed, localized (does not require any global knowledge), lightweight, and is simple to implement. It is also scalable, as it runs in polylogarithmic time and requires nodes to send and receive messages of only polylogarithmic size per round.  To the best of our knowledge, our algorithm is the first scalable solution for Byzantine leader election in a  dynamic network with a high rate of churn; our protocol can also be used to solve Byzantine agreement in a straightforward way.  We also show how to implement an (almost-everywhere) public coin with constant bias in a dynamic network with Byzantine nodes and provide a mechanism for enabling honest nodes to store information reliably in the network, which might be of independent interest.  In decentralized and dynamic P2P systems where a substantial part of the network may be controlled by malicious nodes, the presented algorithm and techniques  can serve as building blocks for designing robust and secure distributed protocols.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Gracefully Degrading Consensus and k-Set Agreement in Directed Dynamic Networks</span><a href="http://dx.doi.org/10.1007/978-3-319-26850-7_8" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Martin Biely, Peter Robinson, Ulrich Schmid, Manfred Schwarz, Kyrill Winkler. <span class="publicationInfo">2nd International Conference on Networked Systems</span> (<span class="publicationConfShort">NETYS 2015</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">We present the first consensus/k-set agreement algorithm for synchronous dynamic networks with unidirectional links, controlled by an omniscient message adversary, which automatically adapts to the actual network properties in a run: If the network is sufficiently well-connected, it solves consensus, while it degrades gracefully to general k-set agreement in less well-connected communication graphs. The actual number k of system-wide decision values is determined by the number of certain vertex-stable root components occurring in a run, which are strongly connected components without incoming links from outside. Related impossibility results reveal that our condition is reasonably close to the solvability border for k-set agreement.</div></li></ul></div><div class="yearContainer"><span class="year">2014</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Distributed Agreement in Dynamic Peer-to-Peer Networks</span><a href="https://www.dropbox.com/s/dncy2vxs9kfc7h6/JCSS2015.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://dx.doi.org/10.1016/j.jcss.2014.10.005" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>John Augustine, Gopal Pandurangan, Peter Robinson, Eli Upfal. <span class="publicationInfo">Journal of Computer and System Sciences, Elsevier.</span> (<span class="publicationConfShort">JCSS</span>). <br></li></ul></div><div class="yearContainer"><span class="year">2013</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Fast Byzantine Agreement in Dynamic Networks</span><a href="https://www.dropbox.com/s/grsjk7uwxilm2wz/PODC2013-1.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://doi.acm.org/10.1145/2484239.2484274" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>John Augustine, Gopal Pandurangan, Peter Robinson <span class="publicationInfo">32nd ACM Symposium on Principles of Distributed Computing</span> (<span class="publicationConfShort">PODC 2013</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">We study Byzantine agreement in dynamic networks where topology  can change from round to round and nodes can also experience heavy  churn (i.e., nodes can join and leave the network continuously over time).  Our main contributions are  randomized  distributed algorithms that guarantee   almost-everywhere Byzantine agreement with high probability even under a large number of Byzantine nodes and continuous adversarial churn in a number of rounds that is polylogarithmic in $n$ (where $n$ is the stable network size). We show that our algorithms are essentially optimal (up to polylogarithmic factors)  with respect to the amount of Byzantine nodes and churn rate that they can tolerate by showing lower bound. In particular, we present the following results: \begin{enumerate} \item An $O(\log^3 n)$ round   randomized algorithm that achieves almost-everywhere Byzantine agreement with high probability under a presence of up to $O(\sqrt{n}/\text{polylog}(n))$ Byzantine nodes and up to a churn of $O(\sqrt{n}/\text{polylog}(n))$ nodes per round. We assume that the Byzantine nodes have knowledge about the entire state of network at every round (including random choices made by all the nodes) and can behave arbitrarily. We also assume that an  adversary controls the  churn --- it has  complete knowledge and control of what nodes join and leave and  at what time  and has unlimited computational power (but is oblivious to the topology changes from round to round).  Our algorithm requires only polylogarithmic  in $n$  bits to be processed and sent (per round) by each node.  \item We also present an $O(\log^3 n)$ round randomized algorithm that has same guarantees as the above algorithm, but works even when the churn and network topology is controlled by an adaptive adversary (that can choose the topology based on the current states of the nodes). However, this algorithm requires up to polynomial in $n$ bits to be processed and sent (per round) by each node.  \item We show that the above bounds  are essentially the best possible, if one wants fast (i.e., polylogarithmic run time)  algorithms, by showing that  any (randomized) algorithm to achieve   agreement in a dynamic network controlled by an adversary  that can churn up to $\Theta(\sqrt{ n \log n})$ nodes per round should take at least a  polynomial number of rounds.  \end{enumerate} Our algorithms are the first-known, fully-distributed, Byzantine agreement algorithms in highly dynamic networks.  We view our results as a step towards understanding the possibilities and limitations of highly dynamic networks that are subject to malicious behavior by a large number of nodes.</div></li></ul></div><div class="yearContainer"><span class="year">2012</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Towards Robust and Efficient Computation in Dynamic Peer-to-Peer Networks</span><a href="https://www.dropbox.com/s/7dkyl2ow32qkll3/SODA2012.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://portal.acm.org/citation.cfm?id=2095163&amp;CFID=63838676&amp;CFTOKEN=79617016" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>John Augustine, Gopal Pandurangan, Peter Robinson, Eli Upfal. <span class="publicationInfo">23rd ACM-SIAM Symposium on Discrete Algorithms</span> (<span class="publicationConfShort">SODA 2012</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">Motivated by the need for robust and fast distributed computation in highly dynamic Peer-to-Peer (P2P) networks, we study algorithms for  the fundamental  distributed agreement problem.   P2P networks  are  highly dynamic networks  that experience heavy node churn (i.e., nodes  join and leave the network continuously over time). Our goal  is to design fast  algorithms (running in a small number of rounds) that guarantee, despite high node churn rate,  that almost all nodes   reach a stable agreement.  Our main contributions are randomized  distributed algorithms that guarantee   stable almost-everywhere agreement with high probability even under high adversarial churn in a polylogarithmic number of rounds.  In particular, we present the following results: \begin{enumerate} \item An $O(\log^2 n)$-round  ($n$ is the stable network size) randomized algorithm that achieves almost-everywhere agreement with high probability under up to linear churn  per round (i.e., $\epsilon n$, for some small constant $\epsilon &gt; 0$), assuming that the churn is controlled by an oblivious adversary (that has  complete knowledge and control of what nodes join and leave and  at what time  and has unlimited computational power, but is oblivious to the random choices made by the algorithm).  \item An $O(\log m\log^3 n)$-round randomized algorithm that achieves almost-everywhere agreement with high probability under up to $\epsilon \sqrt{n}$ churn  per round (for some small $\epsilon &gt; 0$), where $m$ is the size of the input value domain, that works even under an adaptive adversary (that also knows the past random choices made by the algorithm). \item We also show that no deterministic algorithm can guarantee almost-everywhere agreement (regardless of the number of rounds), even under constant churn rate.  \end{enumerate} Our algorithms are the first-known, fully-distributed,  agreement algorithms that work under highly dynamic settings (i.e., high churn rates per step).  Furthermore, they are  localized (i.e., do not require any global topological knowledge), simple, and easy to implement.  These algorithms can serve as building blocks for implementing other non-trivial distributed computing tasks in dynamic P2P networks.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Agreement in Directed Dynamic Networks</span><a href="https://www.dropbox.com/s/0rx40khhv6qax81/SIROCCO2012.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://dx.doi.org/10.1007/978-3-642-31104-8_7" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Martin Biely, Peter Robinson, Ulrich Schmid. <span class="publicationInfo">19th International Colloquium on Structural Information and Communication Complexity</span> (<span class="publicationConfShort">SIROCCO 2012</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">We study distributed computation in synchronous dynamic networks where an omniscient adversary controls the unidirectional communication links. Its behavior is modeled as a sequence of directed graphs representing the active (i.e. timely) communication links per round.  We prove that consensus is impossible under some natural weak connectivity assumptions and introduce vertex-stable root components as a means for circumventing this impossibility.  Essentially, we assume that there is a short period of time during which an arbitrary part of the network remains strongly connected, while its interconnect topology may keep changing continuously.  We present a consensus algorithm that works under this assumption and prove its correctness. Our algorithm maintains a local estimate of the communication graphs and applies techniques for detecting stable network properties and univalent system configurations.  Our possibility results are complemented by several impossibility results and lower bounds for consensus and other distributed computing problems like leader election, revealing that our algorithm is asymptotically optimal.</div></li></ul></div><div class="yearContainer"><span class="year">2011</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Easy Impossibility Proofs for k-Set Agreement in Message Passing Systems</span><a href="OPODIS 201://www.dropbox.com/s/ohur8g25xz858z3/OPODIS2011.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://dx.doi.org/10.1007/978-3-642-25873-2_21" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Martin Biely, Peter Robinson, Ulrich Schmid. <span class="publicationInfo">15th International Conference On Principles Of Distributed Systems</span> (<span class="publicationConfShort">OPODIS 2011</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">Despite of being quite similar agreement problems, distributed consensus ($1$-set agreement) and general $k$-set agreement require surprisingly different techniques for proving their impossibility in asynchronous systems with crash failures: Rather, than the relatively simple bivalence arguments as in the impossibility proof for consensus in the presence of a single crash failure, known proofs for the impossibility of $k$-set agreement in shared memory systems with $f\geq k&gt;1$ crash failures use algebraic topology or a variant of Sperner&#39;s Lemma. In this paper, we present a generic theorem for proving the impossibility of $k$-set agreement in various message passing settings, which is based on a reduction to the consensus impossibility in a certain subsystem resulting from a partitioning argument. We demonstrate the broad applicability of our result by exploring the possibility/impossibility border of $k$-set agreement in several message passing system models: (i) asynchronous systems with crash failures, (ii) partially synchronous processes with (initial) crash failures, and, most importantly, (iii) asynchronous systems augmented with failure detectors.  Furthermore, by extending the algorithm for initial crashes of Fisher, Lynch and Patterson (1985) to general $k$-set agreement, we show that the impossibility border of (i) is tightly matched. The impossibility proofs in cases (i), (ii), and (iii) are instantiations of our main theorem. Regarding (iii), applying our technique reveals the exact border for the parameter $k$ where $k$-set agreement is solvable with the failure detector class $(\Sigma_k,\Omega_k)_{1\le k\le n-1}$ of Bonnet and Raynal.  As $\Sigma_k$ was shown to be necessary for solving $k$-set agreement, this result yields new insights on the quest for the weakest failure detector</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">The Asynchronous Bounded-Cycle Model</span><a href="https://www.dropbox.com/s/56tr3r6dgq7e4i2/TCS2011.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://dx.doi.org/10.1016/j.tcs.2010.08.001" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Peter Robinson and Ulrich Schmid. <span class="publicationInfo">Theoretical Computer Science 412 (2011) 5580â€“5601.</span> (<span class="publicationConfShort">TCS</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">This paper shows how synchrony conditions can be added to the purely asynchronous model in a way that avoids any reference to message delays and computing step times, as well as any global constraints on communication patterns and network topology. Our Asynchronous Bounded-Cycle (ABC) model just bounds the ratio of the number of forward- and backward-oriented messages in certain &#39;&#39;relevant&#39;&#39; cycles in the space-time diagram of an asynchronous execution.  We show that clock synchronization and lock-step rounds can easily be implemented and proved correct in the ABC model, even in the presence of Byzantine failures.  Furthermore, we prove that any algorithm working correctly in the partially synchronous $\Theta$-Model also works correctly in the ABC model. In our proof, we first apply a novel method for assigning certain message delays to asynchronous executions, which is based on a variant of Farkas&#39; theorem of linear inequalities and a non-standard cycle-space of graphs. Using methods from point-set topology, we then prove that the existence of this delay assignment implies model indistinguishability for time-free safety and liveness properties.  Finally, we introduce several weaker variants of the ABC model and relate our model to the existing partially synchronous system models, in particular, the classic models of Dwork, Lynch and Stockmayer. Furthermore, we discuss aspects of the ABC model&#39;s applicability in real systems, in particular, in the context of VLSI Systems-on-Chip.</div></li></ul></div></div><div class="intro revealOnScroll"><h2><a class="anchor" id="Code">Code</a></h2><div>I&#39;m interested in parallel and distributed programming and related technologies such as software transactional memory and the actor-model. Recently, I have been working on implementing a simulation environment for distributed algorithms in Elixir/Erlang, and implementing non-blocking data structures in Haskell suitable for multi-core machines. Below is a (non-comprehensive) list of software that I have written. </div><ul class="longList fa-ul"><li><i class="fa fa-li fa-caret-right"></i><a class="external" href="http://hackage.haskell.org/package/concurrent-hashtable">concurrent hash table:</a> a thread-safe hash table that scales to multicores.</li><li><i class="fa fa-li fa-caret-right"></i><a class="external" href="http://hackage.haskell.org/package/data-dispersal">data dispersal:</a> an implementation of an (m,n)-threshold information dispersal scheme that is space-optimal.</li><li><i class="fa fa-li fa-caret-right"></i><a class="external" href="http://hackage.haskell.org/package/secret-sharing">secret sharing:</a> an implementation of a secret sharing scheme that provides information-theoretic security.</li><li><i class="fa fa-li fa-caret-right"></i><a class="external" href="http://hackage.haskell.org/package/tskiplist">tskiplist:</a> a data structure with range-query support for software transactional memory.</li><li><i class="fa fa-li fa-caret-right"></i><a class="external" href="http://hackage.haskell.org/package/stm-io-hooks">stm-io-hooks:</a> An extension of Haskell&#39;s Software Transactional Memory (STM) monad with commit and retry IO hooks.</li><li><i class="fa fa-li fa-caret-right"></i><a class="external" href="http://hackage.haskell.org/package/mathgenealogy">Mathgenealogy:</a> Visualize your (academic) genealogy! A program for extracting data from the Mathematics Genealogy project.</li><li><i class="fa fa-li fa-caret-right"></i>I extended Haskell&#39;s <a class="external" href="https://www.haskell.org/cabal/">Cabal,</a> for using a &quot;world&quot; file to keep track of installed packages.  (Now part of the main distribution.)</li></ul></div><div class="intro revealOnScroll" id="teaching"><h2><a class="anchor" id="Teaching">Teaching</a></h2><ul class="longList fa-ul"><li><i class="fa fa-li fa-caret-right"></i>Computer Networks, Fall 2020, 2019.</li><li><i class="fa fa-li fa-caret-right"></i>Database Systems, Spring 2020.</li><li><i class="fa fa-li fa-caret-right"></i>Distributed Computing, Spring 2019.</li><li><i class="fa fa-li fa-caret-right"></i>Randomized Algorithms, Fall 2018: <a class="external" href="https://www.cas.mcmaster.ca/robinson/teaching/cas781/intro_slides/">Intro slides. </a><a class="external" href="https://www.cas.mcmaster.ca/robinson/teaching/cas781/markov/">Part 1 on Concentration Bounds.</a></li><li><i class="fa fa-li fa-caret-right"></i>Advanced Distributed Systems, Fall 2016, 2017.</li><li><i class="fa fa-li fa-caret-right"></i>Computation with Data, Fall 2016.</li><li><i class="fa fa-li fa-caret-right"></i>Internet and Web Technologies, Spring 2016.</li></ul></div><div class="intro revealOnScroll" id="misc"><h2><a class="anchor" id="Misc">Misc</a></h2><ul class="longList fa-ul"><li><i class="fa fa-li fa-caret-right"></i>Google scholar <a class="external" href="http://scholar.google.com/citations?user=DsPjnMQAAAAJ&amp;hl=en">profile</a></li><li><i class="fa fa-li fa-caret-right"></i>My profile on <a class="external" href="http://stackexchange.com/users/555378/monoid">StackExchange</a></li></ul></div></div></div></div></body></html>