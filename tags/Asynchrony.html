<!DOCTYPE HTML>
<html><head><link href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" rel="stylesheet"><link href="https://lowerbound.io/style1.css" rel="stylesheet"><link href="https://lowerbound.io/style2.css" rel="stylesheet"><script type="text/javascript">document.documentElement.className = document.documentElement.className.replace(/no-js/,'js');</script><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script src="jquery.waypoints.min.js"></script><script src="jquery.isonscreen.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script><script type="text/javascript" async="true" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML"></script><script type="text/javascript" src="https://lowerbound.io/script.js"></script><style type="text/css">.MathJax_Preview {color: #888} #MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap} #MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px} .MathJax_Error {color: #CC0000; font-style: italic}</style></head><body><div class="outerContainer"><div id="main"><div id="top_container"><div id="header"><div id="header_container"><div id="address"><h2 id="myname">Peter Robinson</h2><p class="email"><a href="mailto:peter(dot)robinson(at)cityu(dot)edu(dot)hk">peter dot robinson at cityu dot edu dot hk</a></p></div><div id="mypic"><img id="myimg" src="pic.jpg" alt="" width="156" height="204"></div></div><ul id="nav"><li><a class="navLink" id="about" href="#About">About</a></li><li><a class="navLink" id="publications" href="#Publications">Publications</a></li><li><a class="navLink" id="code" href="#Code">Code</a></li><li><a class="navLink" id="teaching" href="#Teaching">Teaching</a></li><li><a class="navLink" id="misc" href="#Misc">Misc</a></li></ul></div></div><div class="mycontainer" class="anchor" id="About"><div class="intro">My research focuses on designing new distributed and parallel algorithms, the distributed processing of big data, achieving fault-tolerance in communication networks against adversarial attacks, and developing robust protocols that work in highly dynamic environments such as peer-to-peer Blockchain networks and mobile ad-hoc networks.</div><div class="intro"><h2>News</h2><ul id="newsList" class="fa-ul"><li><i class="fa fa-li fa-caret-right"></i>General Chair of ACM PODC 2019</li><li><i class="fa fa-li fa-caret-right"></i>Program committee member of <a href="http://www.podc.org">PODC 2020</a>, <a href="http://www.podc.org">SIROCCO 2020</a>, <a href="http://www.disc-conference.org/wp/">DISC 2019</a></li></ul></div><div class="tagCloud"><h2 class="tagCloud">Tags <a href="../index.html">(Show all)</a></h2><a class="keyword" style="font-size: 1.5372436em; color:red;" href="https://lowerbound.io//tags/Asynchrony.html#Publications"> Asynchrony  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Big Data.html#Publications"> Big Data  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Byzantine Failures.html#Publications"> Byzantine Failures  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Churn.html#Publications"> Churn  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Communication Complexity.html#Publications"> Communication Complexity  </a><a class="keyword" style="font-size: 1.8510257em" href="https://lowerbound.io//tags/Distributed Agreement.html#Publications"> Distributed Agreement  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Distributed Storage.html#Publications"> Distributed Storage  </a><a class="keyword" style="font-size: 1.7124022em" href="https://lowerbound.io//tags/Dynamic Network.html#Publications"> Dynamic Network  </a><a class="keyword" style="font-size: 2.0em" href="https://lowerbound.io//tags/Fault-Tolerance.html#Publications"> Fault-Tolerance  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Gossip Communication.html#Publications"> Gossip Communication  </a><a class="keyword" style="font-size: 1.761878em" href="https://lowerbound.io//tags/Graph Algorithm.html#Publications"> Graph Algorithm  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Haskell.html#Publications"> Haskell  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Information Complexity.html#Publications"> Information Complexity  </a><a class="keyword" style="font-size: 1.5372436em" href="https://lowerbound.io//tags/Leader Election.html#Publications"> Leader Election  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Machine Learning.html#Publications"> Machine Learning  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Mobile Ad-Hoc Network.html#Publications"> Mobile Ad-Hoc Network  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Natural Language Processing.html#Publications"> Natural Language Processing  </a><a class="keyword" style="font-size: 1.4669032em" href="https://lowerbound.io//tags/P2P.html#Publications"> P2P  </a><a class="keyword" style="font-size: 1.6008743em" href="https://lowerbound.io//tags/Secure Computation in Networks.html#Publications"> Secure Computation in Networks  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Self-Healing.html#Publications"> Self-Healing  </a><a class="keyword" style="font-size: 1.2991215em" href="https://lowerbound.io//tags/Symmetry Breaking.html#Publications"> Symmetry Breaking  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Wireless Networks.html#Publications"> Wireless Networks  </a></div><h2><a class="anchor" id="Publications">Publications</a></h2><div class="publicationList"><div class="yearContainer"><span class="year">2020</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Latency, Capacity, and Distributed Minimum Spanning Tree.</span><br>John Augustine, Seth Gilbert, Fabian Kuhn, Peter Robinson, Suman Sourav. <span class="publicationInfo">40th IEEE International Conference on Distributed Computing Systems</span> (<span class="publicationConfShort">ICDCS 2020</span>). <br></li></ul></div><div class="yearContainer"><span class="year">2019</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Slow Links, Fast Links, and the Cost of Gossip.</span><a href="https://doi.org/10.1109/TPDS.2019.2905568" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Seth Gilbert, Peter Robinson, Suman Sourav. <span class="publicationInfo">IEEE Transactions on Parallel and Distributed Systems</span> (<span class="publicationConfShort">IEEE TPDS</span>). <br></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">On the Hardness of the Strongly Dependent Decision Problem.</span><br>Martin Biely and Peter Robinson. <span class="publicationInfo">20th International Conference on Distributed Computing and Networking</span> (<span class="publicationConfShort">ICDCN 2019</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">We present necessary and sufficient conditions for solving the strongly dependent decision (SDD) problem in various distributed systems. Our main contribution is a novel characterization of the SDD problem based on point-set topology. For partially synchronous systems, we show that any algorithm that solves the SDD problem induces a set of executions that is closed with respect to the point-set topology. We also show that the SDD problem is not solvable in the asynchronous system augmented with any arbitrarily strong failure detectors.</div></li></ul></div><div class="yearContainer"><span class="year">2018</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Slow Links, Fast Links, and the Cost of Gossip</span><a href="http://doi.ieeecomputersociety.org/10.1109/ICDCS.2018.00081" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Seth Gilbert, Peter Robinson, Suman Sourav. <span class="publicationInfo">38th IEEE International Conference on Distributed Computing Systems</span> (<span class="publicationConfShort">ICDCS 2018</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">Consider the classical problem of information dissemination: one (or more) nodes in a network have some information that they want to distribute to the remainder of the network.  In this paper, we study the cost of information dissemination in networks where edges have latencies, i.e., sending a message from one node to another takes some amount of time.  We first generalize the idea of conductance to weighted graphs, defining $\phi_*$ to be the ``weighted conductance&#39;&#39; and $\ell_*$ to be the ``critical latency.&#39;&#39;  One goal of this paper is to argue that $\phi_*$ characterizes the connectivity of a weighted graph with latencies in much the same way that conductance characterizes the connectivity of unweighted graphs.  We give near tight upper and lower bounds on the problem of information dissemination, up to polylogarithmic factors.  Specifically, we show that in a graph with (weighted) diameter $D$ (with latencies as weights), maximum degree $\Delta$, weighted conductance $\phi_*$ and critical latency $\ell_*$, any information dissemination algorithm requires at least $\Omega(\min(D+\Delta, \ell_*/\phi_*))$ time. We show several variants of the lower bound (e.g., for graphs with small diameter, graphs with small max-degree, etc.) by reduction to a simple combinatorial game.  We then give nearly matching algorithms, showing that information dissemination can be solved in $O(\min((D + \Delta)\log^3{n}), (\ell_*/\phi_*)\log(n))$ time.  % $O(\min(D\log^3(n), \ell_*\log(n)/\phi_*))$.  The algorithm consists of two sub-algorithms: This is achieved by combining two cases.  When nodes do not know the latency of the adjacent edges, we show that the classical push-pull algorithm is (near) optimal when the diameter or maximum degree is large.  For the case where the diameter and maximum degree are small, we give an alternative strategy in which we first discover the latencies and then use an algorithm for known latencies based on a weighted spanner construction.  (Our algorithms are within polylogarithmic factors of being tight both for known and unknown latencies.) </div></li></ul></div><div class="yearContainer"><span class="year">2014</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">The Generalized Loneliness Detector and Weak System Models for k-Set Agreement</span><a href="https://www.dropbox.com/s/1t7l5tsyu4g9ktu/TPDS2014.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://dx.doi.org/10.1109/TPDS.2013.77" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Martin Biely, Peter Robinson, Ulrich Schmid. <span class="publicationInfo">IEEE Transactions on Parallel and Distributed Systems, vol. 25(4), 1078-1088</span> (<span class="publicationConfShort">IEEE TPDS</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">This paper presents two weak partially synchronous system models MAnti[n-k] and MSink[n-k], which are just strong enough for solving $k$-set agreement: We introduce the generalized $(n-k)$-loneliness failure detector $\mathcal{L}(k)$, which we first prove to be sufficient for solving $k$-set agreement, and show that $\mathcal{L}(k)$ but not $\mathcal{L}(k-1)$ can be implemented in both models.  MAnti[n-k] and MSink[n-k] are hence the first message passing models that lie between models where $\Omega$ (and therefore consensus) can be implemented and the purely asynchronous model.  We also address $k$-set agreement in anonymous systems, that is, in systems where (unique) process identifiers are not available. Since our novel $k$-set agreement algorithm using $\mathcal{L}(k)$ also works in anonymous systems, it turns out that the loneliness failure detector $\mathcal{L}=\mathcal{L}(n-1)$ introduced by Delporte et al. is also the weakest failure detector for set agreement in anonymous systems. Finally, we analyze the relationship between $\mathcal{L}(k)$ and other failure detectors suitable for solving $k$-set agreement.</div></li></ul></div><div class="yearContainer"><span class="year">2011</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Weak System Models for Fault-Tolerant Distributed Agreement Problems</span><br>Peter Robinson. <span class="publicationInfo">PhD Thesis in Computer Science.</span><br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">This thesis investigates various aspects of weak system models for agreement problems in fault-tolerant distributed computing.  In Part~I we provide an introduction to the context of this work, discuss related literature and describe the basic system assumptions. In Part~II of this thesis, we introduce the Asynchronous Bounded-Cycle (ABC) model, which is entirely time-free.  In contrast to existing system models, the ABC model does not require explicit time-based synchrony bounds, but rather stipulates a graph-theoretic synchrony condition on the relative lengths of certain causal chains of messages in the space-time graph of a run.  We compare the ABC model to other models in literature, in particular to the classic models by Dwork, Lynch, and Stockmeyer.  Despite Byzantine failures, we show how to simulate lock-step rounds, and therefore make consensus solvable, and prove the correctness of a clock synchronization algorithm in the ABC model.  We then present the technically most involved result of this thesis: We prove that any algorithm working correctly in the partially synchronous $\Theta$-Model by Le Lann and Schmid, also works correctly in the time-free ABC model.  In the proof, we use a variant of Farkas&#39; Theorem of Linear Inequalities and develop a non-standard cycle space on directed graphs in order to guarantee the existence of a certain message delay transformation for finite prefixes of runs.  This shows that any time-free safety property satisfied by an algorithm in the $\Theta$-Model also holds in the ABC model.  By employing methods from point-set topology, we can extend this result to liveness properties. In Part~III, we shift our attention to the borderland between models where consensus is solvable and the purely asynchronous model.  To this end, we look at the $k$-set agreement problem where processes need to decide on at most $k$ distinct decision values.  We introduce two very weak system models MAnti and MSink and prove that consensus is impossible in these models.  Nevertheless, we show that $(n-1)$-set agreement is solvable in MAnti and MSink, by providing algorithms that implement the weakest failure detector $\mathcal{L}$.  We also discuss how models MAnti and MSink relate to the $f$-source models by Aguilera et al. for solving consensus. In the subsequent chapter, we present a novel failure detector $\mathcal{L}(k)$ that generalizes $\mathcal{L}$, and analyze an algorithm for solving $k$-set agreement with $\mathcal{L}(k)$, which works even in systems without unique process identifiers.  Moreover, We explore  the relationship between $\mathcal{L}(k)$ and existing failure detectors for $k$-set agreement.  Some aspects of $\mathcal{L}(k)$ relating to anonymous systems  are also discussed. Next, we present a generic theorem that can be used to characterize the impossibility of achieving $k$-set agreement in various system models.  This enables us to show that $(\Sigma_k,\Omega_k)$ is not sufficient for solving $k$-set agreement.  Furthermore, we instantiate our theorem with a partially synchronous system model. Finally, we consider the $k$-set agreement problem in round-based systems.  First, we introduce a novel abstraction that encapsulates the perpetual synchrony of a run, the so called stable skeleton graph, which allows us to express the solvability power of a system via graph-theoretic properties.  We then present an approximation algorithm where processes output an estimate of their respective component of the stable skeleton graph.  We define a class of communication predicates PSources(k) in this framework, and show that PSources(k) tightly captures the amount of synchrony necessary for $k$-set agreement, as $(k-1)$-set agreement is impossible with PSources(k).  Based on the stable skeleton approximation, we present an algorithm that solves $k$-set agreement when PSources(k) holds.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Easy Impossibility Proofs for k-Set Agreement in Message Passing Systems</span><a href="OPODIS 201://www.dropbox.com/s/ohur8g25xz858z3/OPODIS2011.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://dx.doi.org/10.1007/978-3-642-25873-2_21" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Martin Biely, Peter Robinson, Ulrich Schmid. <span class="publicationInfo">15th International Conference On Principles Of Distributed Systems</span> (<span class="publicationConfShort">OPODIS 2011</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">Despite of being quite similar agreement problems, distributed consensus ($1$-set agreement) and general $k$-set agreement require surprisingly different techniques for proving their impossibility in asynchronous systems with crash failures: Rather, than the relatively simple bivalence arguments as in the impossibility proof for consensus in the presence of a single crash failure, known proofs for the impossibility of $k$-set agreement in shared memory systems with $f\geq k&gt;1$ crash failures use algebraic topology or a variant of Sperner&#39;s Lemma. In this paper, we present a generic theorem for proving the impossibility of $k$-set agreement in various message passing settings, which is based on a reduction to the consensus impossibility in a certain subsystem resulting from a partitioning argument. We demonstrate the broad applicability of our result by exploring the possibility/impossibility border of $k$-set agreement in several message passing system models: (i) asynchronous systems with crash failures, (ii) partially synchronous processes with (initial) crash failures, and, most importantly, (iii) asynchronous systems augmented with failure detectors.  Furthermore, by extending the algorithm for initial crashes of Fisher, Lynch and Patterson (1985) to general $k$-set agreement, we show that the impossibility border of (i) is tightly matched. The impossibility proofs in cases (i), (ii), and (iii) are instantiations of our main theorem. Regarding (iii), applying our technique reveals the exact border for the parameter $k$ where $k$-set agreement is solvable with the failure detector class $(\Sigma_k,\Omega_k)_{1\le k\le n-1}$ of Bonnet and Raynal.  As $\Sigma_k$ was shown to be necessary for solving $k$-set agreement, this result yields new insights on the quest for the weakest failure detector</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">The Asynchronous Bounded-Cycle Model</span><a href="https://www.dropbox.com/s/56tr3r6dgq7e4i2/TCS2011.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://dx.doi.org/10.1016/j.tcs.2010.08.001" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Peter Robinson and Ulrich Schmid. <span class="publicationInfo">Theoretical Computer Science 412 (2011) 5580â€“5601.</span> (<span class="publicationConfShort">TCS</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">This paper shows how synchrony conditions can be added to the purely asynchronous model in a way that avoids any reference to message delays and computing step times, as well as any global constraints on communication patterns and network topology. Our Asynchronous Bounded-Cycle (ABC) model just bounds the ratio of the number of forward- and backward-oriented messages in certain &#39;&#39;relevant&#39;&#39; cycles in the space-time diagram of an asynchronous execution.  We show that clock synchronization and lock-step rounds can easily be implemented and proved correct in the ABC model, even in the presence of Byzantine failures.  Furthermore, we prove that any algorithm working correctly in the partially synchronous $\Theta$-Model also works correctly in the ABC model. In our proof, we first apply a novel method for assigning certain message delays to asynchronous executions, which is based on a variant of Farkas&#39; theorem of linear inequalities and a non-standard cycle-space of graphs. Using methods from point-set topology, we then prove that the existence of this delay assignment implies model indistinguishability for time-free safety and liveness properties.  Finally, we introduce several weaker variants of the ABC model and relate our model to the existing partially synchronous system models, in particular, the classic models of Dwork, Lynch and Stockmayer. Furthermore, we discuss aspects of the ABC model&#39;s applicability in real systems, in particular, in the context of VLSI Systems-on-Chip.</div></li></ul></div><div class="yearContainer"><span class="year">2009</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Weak Synchrony Models and Failure Detectors for Message Passing k-Set Agreement</span><a href="http://www.springerlink.com/content/530741614w724416/" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Martin Biely, Peter Robinson, Ulrich Schmid. <span class="publicationInfo">13th International Conference On Principles Of Distributed Systems</span> (<span class="publicationConfShort">OPODIS 2009</span>). <br></li></ul></div><div class="yearContainer"><span class="year">2008</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">The Asynchronous Bounded-Cycle Model</span><a href="http://dx.doi.org/10.1007/978-3-540-89335-6_20" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Peter Robinson and Ulrich Schmid. <span class="publicationInfo">10th International Symposium on Stabilization, Safety, and Security of Distributed Systems</span> (<span class="publicationConfShort">SSS 2008</span>). <span class="bestPaper">Best Paper Award.</span><br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">This paper shows how synchrony conditions can be added to the purely asynchronous model in a way that avoids any reference to message delays and computing step times, as well as any global constraints on communication patterns and network topology. Our Asynchronous Bounded-Cycle (ABC) model just bounds the ratio of the number of forward- and backward-oriented messages in certain &#39;&#39;relevant&#39;&#39; cycles in the space-time diagram of an asynchronous execution.  We show that clock synchronization and lock-step rounds can easily be implemented and proved correct in the ABC model, even in the presence of Byzantine failures.  Furthermore, we prove that any algorithm working correctly in the partially synchronous $\Theta$-Model also works correctly in the ABC model. In our proof, we first apply a novel method for assigning certain message delays to asynchronous executions, which is based on a variant of Farkas&#39; theorem of linear inequalities and a non-standard cycle-space of graphs. Using methods from point-set topology, we then prove that the existence of this delay assignment implies model indistinguishability for time-free safety and liveness properties.  Finally, we introduce several weaker variants of the ABC model and relate our model to the existing partially synchronous system models, in particular, the classic models of Dwork, Lynch and Stockmayer. Furthermore, we discuss aspects of the ABC model&#39;s applicability in real systems, in particular, in the context of VLSI Systems-on-Chip.</div></li></ul></div></div><div class="intro revealOnScroll"><h2><a class="anchor" id="Code">Code</a></h2><div>I&#39;m interested in parallel and distributed programming and related technologies such as software transactional memory and the actor-model. Recently, I have been working on implementing a simulation environment for distributed algorithms in Elixir/Erlang, and implementing non-blocking data structures in Haskell suitable for multi-core machines. Below is a (non-comprehensive) list of software that I have written. </div><ul class="longList fa-ul"><li><i class="fa fa-li fa-caret-right"></i><a class="external" href="http://hackage.haskell.org/package/concurrent-hashtable">concurrent hash table:</a> a thread-safe hash table that scales to multicores.</li><li><i class="fa fa-li fa-caret-right"></i><a class="external" href="http://hackage.haskell.org/package/data-dispersal">data dispersal:</a> an implementation of an (m,n)-threshold information dispersal scheme that is space-optimal.</li><li><i class="fa fa-li fa-caret-right"></i><a class="external" href="http://hackage.haskell.org/package/secret-sharing">secret sharing:</a> an implementation of a secret sharing scheme that provides information-theoretic security.</li><li><i class="fa fa-li fa-caret-right"></i><a class="external" href="http://hackage.haskell.org/package/tskiplist">tskiplist:</a> a data structure with range-query support for software transactional memory.</li><li><i class="fa fa-li fa-caret-right"></i><a class="external" href="http://hackage.haskell.org/package/stm-io-hooks">stm-io-hooks:</a> An extension of Haskell&#39;s Software Transactional Memory (STM) monad with commit and retry IO hooks.</li><li><i class="fa fa-li fa-caret-right"></i><a class="external" href="http://hackage.haskell.org/package/mathgenealogy">Mathgenealogy:</a> Visualize your (academic) genealogy! A program for extracting data from the Mathematics Genealogy project.</li><li><i class="fa fa-li fa-caret-right"></i>I extended Haskell&#39;s <a class="external" href="https://www.haskell.org/cabal/">Cabal,</a> for using a &quot;world&quot; file to keep track of installed packages.  (Now part of the main distribution.)</li></ul></div><div class="intro revealOnScroll" id="teaching"><h2><a class="anchor" id="Teaching">Teaching</a></h2><ul class="longList fa-ul"><li><i class="fa fa-li fa-caret-right"></i>CAS781 Randomized Algorithms, Fall 2018: <a class="external" href="https://www.cas.mcmaster.ca/robinson/teaching/cas781/markov/">More slides.</a><a class="external" href="https://www.cas.mcmaster.ca/robinson/teaching/cas781/intro_slides/">Intro slides.</a></li><li><i class="fa fa-li fa-caret-right"></i>CS5860 Advanced Distributed Systems, Fall 2016, 2017.</li><li><i class="fa fa-li fa-caret-right"></i>CS5800 Computation with Data, Fall 2016.</li><li><i class="fa fa-li fa-caret-right"></i>BI5632 Internet and Web Technologies, Spring 2016.</li><li><i class="fa fa-li fa-caret-right"></i>CSC2008 Networks and Communications, Fall 2015.</li></ul></div><div class="intro revealOnScroll" id="misc"><h2><a class="anchor" id="Misc">Misc</a></h2><ul class="longList fa-ul"><li><i class="fa fa-li fa-caret-right"></i>Google scholar <a class="external" href="http://scholar.google.com.sg/citations?user=DsPjnMQAAAAJ&amp;hl=en">profile</a></li><li><i class="fa fa-li fa-caret-right"></i>My profile on <a class="external" href="http://stackexchange.com/users/555378/monoid">StackExchange</a></li></ul></div></div></div></div></body></html>