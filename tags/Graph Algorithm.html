<!DOCTYPE HTML>
<html><head><link href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" rel="stylesheet"><link href="https://lowerbound.io/style1.css" rel="stylesheet"><link href="https://lowerbound.io/style2.css" rel="stylesheet"><script type="text/javascript">document.documentElement.className = document.documentElement.className.replace(/no-js/,'js');</script><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script src="jquery.waypoints.min.js"></script><script src="jquery.isonscreen.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script><script type="text/javascript" async="true" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML"></script><script type="text/javascript" src="https://lowerbound.io/script.js"></script><style type="text/css">.MathJax_Preview {color: #888} #MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap} #MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px} .MathJax_Error {color: #CC0000; font-style: italic}</style></head><body><div class="outerContainer"><div id="main"><div id="top_container"><div id="header"><div id="header_container"><div id="address"><h2 id="myname">Peter Robinson</h2><p class="email"><a href="mailto:peter(dot)robinson(at)cityu(dot)edu(dot)hk">peter dot robinson at cityu dot edu dot hk</a></p></div><div id="mypic"><img id="myimg" src="pic.jpg" alt="" width="156" height="204"></div></div><ul id="nav"><li><a class="navLink" id="about" href="#About">About</a></li><li><a class="navLink" id="publications" href="#Publications">Publications</a></li><li><a class="navLink" id="code" href="#Code">Code</a></li><li><a class="navLink" id="teaching" href="#Teaching">Teaching</a></li><li><a class="navLink" id="misc" href="#Misc">Misc</a></li></ul></div></div><div class="mycontainer" class="anchor" id="About"><div class="intro">My research focuses on designing new distributed and parallel algorithms, the distributed processing of big data, achieving fault-tolerance in communication networks against adversarial attacks, and developing robust protocols that work in highly dynamic environments such as peer-to-peer Blockchain networks and mobile ad-hoc networks.</div><div class="intro"><h2>News</h2><ul id="newsList" class="fa-ul"><li><i class="fa fa-li fa-caret-right"></i>General Chair of ACM PODC 2019</li><li><i class="fa fa-li fa-caret-right"></i>Program committee member of <a href="http://www.podc.org">PODC 2020</a>, <a href="http://www.podc.org">SIROCCO 2020</a>, <a href="http://www.disc-conference.org/wp/">DISC 2019</a></li></ul></div><div class="tagCloud"><h2 class="tagCloud">Tags <a href="../index.html">(Show all)</a></h2><a class="keyword" style="font-size: 1.5372436em" href="https://lowerbound.io//tags/Asynchrony.html#Publications"> Asynchrony  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Big Data.html#Publications"> Big Data  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Byzantine Failures.html#Publications"> Byzantine Failures  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Churn.html#Publications"> Churn  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Communication Complexity.html#Publications"> Communication Complexity  </a><a class="keyword" style="font-size: 1.8510257em" href="https://lowerbound.io//tags/Distributed Agreement.html#Publications"> Distributed Agreement  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Distributed Storage.html#Publications"> Distributed Storage  </a><a class="keyword" style="font-size: 1.7124022em" href="https://lowerbound.io//tags/Dynamic Network.html#Publications"> Dynamic Network  </a><a class="keyword" style="font-size: 2.0em" href="https://lowerbound.io//tags/Fault-Tolerance.html#Publications"> Fault-Tolerance  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Gossip Communication.html#Publications"> Gossip Communication  </a><a class="keyword" style="font-size: 1.761878em; color:red;" href="https://lowerbound.io//tags/Graph Algorithm.html#Publications"> Graph Algorithm  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Haskell.html#Publications"> Haskell  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Information Complexity.html#Publications"> Information Complexity  </a><a class="keyword" style="font-size: 1.5372436em" href="https://lowerbound.io//tags/Leader Election.html#Publications"> Leader Election  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Machine Learning.html#Publications"> Machine Learning  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Mobile Ad-Hoc Network.html#Publications"> Mobile Ad-Hoc Network  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Natural Language Processing.html#Publications"> Natural Language Processing  </a><a class="keyword" style="font-size: 1.4669032em" href="https://lowerbound.io//tags/P2P.html#Publications"> P2P  </a><a class="keyword" style="font-size: 1.6008743em" href="https://lowerbound.io//tags/Secure Computation in Networks.html#Publications"> Secure Computation in Networks  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Self-Healing.html#Publications"> Self-Healing  </a><a class="keyword" style="font-size: 1.2991215em" href="https://lowerbound.io//tags/Symmetry Breaking.html#Publications"> Symmetry Breaking  </a><a class="keyword" style="font-size: 1.2em" href="https://lowerbound.io//tags/Wireless Networks.html#Publications"> Wireless Networks  </a></div><h2><a class="anchor" id="Publications">Publications</a></h2><div class="publicationList"><div class="yearContainer"><span class="year">2020</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">DConstructor: Efficient and Robust Network Construction with Polylogarithmic Overhead.</span><br>Seth Gilbert, Gopal Pandurangan, Peter Robinson, Amitabh Trehan. <span class="publicationInfo">39th ACM Symposium on Principles of Distributed Computing</span> (<span class="publicationConfShort">PODC 2020</span>). <br></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">A Time- and Message-Optimal Distributed Algorithm for Minimum Spanning Trees</span><br>Gopal Pandurangan, Peter Robinson, Michele Scquizzato. <span class="publicationInfo">ACM Transactions on Algorithms</span> (<span class="publicationConfShort">ACM TALG</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">This paper presents a randomized (Las Vegas) distributed algorithm that constructs a minimum spanning tree (MST) in weighted networks with optimal (up to polylogarithmic factors) time and message complexity.  This algorithm  runs in $\tilde{O}(D + \sqrt{n})$ time and exchanges $\tilde{O}(m)$ messages (both with high probability), where $n$ is the number of nodes of the network, $D$ is the diameter, and $m$ is the number of edges.  This is the first distributed MST algorithm that matches simultaneously the time lower bound of $\tilde{\Omega}(D + \sqrt{n})$ [Elkin, SIAM J. Comput. 2006] and the message lower bound of $\Omega(m)$ [Kutten et al., JACM 2015], which both apply to randomized Monte Carlo algorithms.  The prior time and message lower bounds are  derived using two completely different graph constructions; the existing lower bound construction that shows one lower bound does not work for the other.  To complement our algorithm, we  present a new lower bound graph construction for which any distributed MST algorithm  requires both $\tilde{\Omega}(D + \sqrt{n})$ rounds and $\Omega(m)$ messages.</div></li></ul></div><div class="yearContainer"><span class="year">2019</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">The Complexity of Symmetry Breaking in Massive Graphs.</span><a href="http://drops.dagstuhl.de/opus/volltexte/2019/11333/" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Christian Konrad, Sriram V. Pemmaraju, Talal Riaz, and Peter Robinson. <span class="publicationInfo">32nd International Symposium on Distributed Computing LIPIcs, Vol. 146</span> (<span class="publicationConfShort">DISC 2019</span>). <br></li></ul></div><div class="yearContainer"><span class="year">2018</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Fast Distributed Algorithms for Connectivity and MST in Large Graphs</span><br>Gopal Pandurangan, Peter Robinson, Michele Scquizzato. <span class="publicationInfo">Special Issue of ACM Transactions on Parallel Computing.</span> (<span class="publicationConfShort">TOPC</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">Motivated by the increasing need to understand the algorithmic foundations of distributed large-scale graph computations, we study a number of fundamental graph problems in a message-passing model for distributed computing where $k \geq 2$ machines jointly perform computations on graphs with $n$ nodes (typically, $n \gg k$).  The input graph is assumed to be initially randomly partitioned among the $k$ machines, a common implementation in many real-world systems. Communication is point-to-point, and the goal is to minimize the number of communication rounds of the computation.  Our main result is an (almost) optimal  distributed randomized algorithm for graph connectivity.  Our algorithm runs in $\tilde{O}(n/k^2)$ rounds ($\tilde{O}$ notation hides a $\text{polylog}(n)$ factor and an additive $\text{polylog}(n)$ term). This improves over the best previously known bound of $\tilde{O}(n/k)$ [Klauck et al., SODA 2015], and is optimal (up to a polylogarithmic factor) in view of an existing lower bound of $\tilde{\Omega}(n/k^2)$. Our improved algorithm uses a bunch of techniques, including linear graph sketching, that prove useful in the design of efficient distributed graph algorithms.  We then present fast randomized algorithms for computing minimum spanning trees, (approximate) min-cuts, and for many graph verification problems. All these algorithms take $\tilde{O}(n/k^2)$ rounds, and are optimal up to polylogarithmic factors.  We also show an almost matching lower bound of $\tilde{\Omega}(n/k^2)$ for many graph verification problems using lower bounds in random-partition communication complexity.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">The Distributed Minimum Spanning Tree Problem</span><a href="http://bulletin.eatcs.org/index.php/beatcs/article/view/538/538" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Gopal Pandurangan, Peter Robinson, Michele Scquizzato. <span class="publicationInfo">Distributed Computing Column, EATCS Bulletin, No 125: June 2018.</span> (<span class="publicationConfShort">EATCS</span>). <br></li></ul></div><div class="yearContainer"><span class="year">2017</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">A Time- and Message-Optimal Distributed Algorithm for Minimum Spanning Trees</span><a href="https://doi.org/10.1145/3055399.3055449" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Gopal Pandurangan, Peter Robinson, Michele Scquizzato. <span class="publicationInfo">49th ACM Symposium on Theory of Computing</span> (<span class="publicationConfShort">STOC 2017</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">This paper presents a randomized (Las Vegas) distributed algorithm that constructs a minimum spanning tree (MST) in weighted networks with optimal (up to polylogarithmic factors) time and message complexity.  This algorithm  runs in $\tilde{O}(D + \sqrt{n})$ time and exchanges $\tilde{O}(m)$ messages (both with high probability), where $n$ is the number of nodes of the network, $D$ is the diameter, and $m$ is the number of edges.  This is the first distributed MST algorithm that matches simultaneously the time lower bound of $\tilde{\Omega}(D + \sqrt{n})$ [Elkin, SIAM J. Comput. 2006] and the message lower bound of $\Omega(m)$ [Kutten et al., JACM 2015], which both apply to randomized Monte Carlo algorithms.  The prior time and message lower bounds are  derived using two completely different graph constructions; the existing lower bound construction that shows one lower bound does not work for the other.  To complement our algorithm, we  present a new lower bound graph construction for which any distributed MST algorithm  requires both $\tilde{\Omega}(D + \sqrt{n})$ rounds and $\Omega(m)$ messages.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Symmetry Breaking in the Congest Model: Message- and Time-Efficient Algorithms for Ruling Sets.</span><br>Shreyas Pai, Gopal Pandurangan, Sriram V. Pemmaraju, Talal Riaz, Peter Robinson. <span class="publicationInfo">31st International Symposium on Distributed Computing</span> (<span class="publicationConfShort">DISC 2017</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">We study local symmetry breaking problems in the Congest model, focusing on ruling set problems, which generalize the fundamental Maximal Independent Set (MIS) problem. The time (round) complexity of MIS (and ruling sets) have attracted much attention in the Local model. Indeed, recent results (Barenboim et al., FOCS 2012, Ghaffari SODA 2016) for the MIS problem have tried to break the long-standing $O(\log n)$-round ``barrier&#39;&#39; achieved by Luby&#39;s algorithm, but these yield $o(\log n)$-round complexity only when the maximum degree $\Delta$ is somewhat small relative to $n$. More importantly, these results apply only in the Local model.  In fact, the best known time bound in the Congest model is still $O(\log n)$ (via Luby&#39;s algorithm) even for somewhat small $\Delta$.  Furthermore, message complexity has been largely ignored in the context of local symmetry breaking. Luby&#39;s algorithm takes $O(m)$ messages on $m$-edge graphs and this is the best known bound with respect to messages. Our work is motivated by the following central question: can we break the $\Theta(m)$ message bound and the $\Theta(\log n)$ time bound in the Congest model for MIS or closely-related symmetry breaking problems?  This paper presents progress towards this question for the distributed ruling set problem in the Congest model.  A $\beta$-ruling set is an independent set such that every node in the graph is at most $\beta$ hops from a node in the independent set. We present the following results: 1. Time Complexity: We show that we can break the $O(\log n)$ ``barrier&#39;&#39; for 2- and 3-ruling sets.  We compute 3-ruling sets in $O\left(\log n/\log \log n\right)$ rounds with high probability (whp).  More generally we show that 2-ruling sets can be computed in $O\left(\log \Delta \cdot (\log n)^{1/2 + \varepsilon} + \log n/\log\log n\right)$ rounds for any $\varepsilon &gt; 0$, which is $o(\log n)$ for a wide range of $\Delta$ values (e.g., $\Delta = 2^{(\log n)^{1/2-\varepsilon}}$).  These are the first 2- and 3-ruling set algorithms to improve over the $O(\log n)$-round complexity of Luby&#39;s algorithm in the Congest model.  2. Message Complexity:  We show an $\Omega(n^2)$ lower bound on the message complexity of computing an MIS (i.e., 1-ruling set) which holds also for randomized algorithms and present a contrast to this by showing a randomized algorithm for 2-ruling sets that, whp, uses  only $O(n \log^2 n)$ messages and runs in $O(\Delta \log n)$ rounds. This is the first message-efficient algorithm known for ruling sets, which takes near-linear message complexity (which is optimal up to a polylogarithmic factor).  Our results are a step toward understanding the  time and message complexity of symmetry breaking problems in the Congest model.</div></li></ul></div><div class="yearContainer"><span class="year">2016</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Fast Distributed Algorithms for Connectivity and MST in Large Graphs</span><a href="http://doi.acm.org/10.1145/2935764.2935785" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Gopal Pandurangan, Peter Robinson, Michele Scquizzato. <span class="publicationInfo">28th ACM Symposium on Parallelism in Algorithms and Architectures</span> (<span class="publicationConfShort">SPAA 2016</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">Motivated by the increasing need to understand the algorithmic foundations of distributed large-scale graph computations, we study a number of fundamental graph problems in a message-passing model for distributed computing where $k \geq 2$ machines jointly perform computations on graphs with $n$ nodes (typically, $n \gg k$).  The input graph is assumed to be initially randomly partitioned among the $k$ machines, a common implementation in many real-world systems. Communication is point-to-point, and the goal is to minimize the number of communication rounds of the computation.  Our main result is an (almost) optimal  distributed randomized algorithm for graph connectivity.  Our algorithm runs in $\tilde{O}(n/k^2)$ rounds ($\tilde{O}$ notation hides a $\text{polylog}(n)$ factor and an additive $\text{polylog}(n)$ term). This improves over the best previously known bound of $\tilde{O}(n/k)$ [Klauck et al., SODA 2015], and is optimal (up to a polylogarithmic factor) in view of an existing lower bound of $\tilde{\Omega}(n/k^2)$. Our improved algorithm uses a bunch of techniques, including linear graph sketching, that prove useful in the design of efficient distributed graph algorithms.  We then present fast randomized algorithms for computing minimum spanning trees, (approximate) min-cuts, and for many graph verification problems. All these algorithms take $\tilde{O}(n/k^2)$ rounds, and are optimal up to polylogarithmic factors.  We also show an almost matching lower bound of $\tilde{\Omega}(n/k^2)$ for many graph verification problems using lower bounds in random-partition communication complexity.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Efficient Computation of Sparse Structures</span><a href="http://onlinelibrary.wiley.com/doi/10.1002/rsa.20653/abstract" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>David G. Harris, Ehab Morsy, Gopal Pandurangan, Peter Robinson, Aravind Srinivasan. <span class="publicationInfo">Random Structures &amp; Algorithms</span> (<span class="publicationConfShort">RSA</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">Basic graph structures such as maximal independent sets (MIS&#39;s)  have spurred much theoretical research in randomized and distributed algorithms, and have several applications in networking and distributed computing as well. However, the extant (distributed) algorithms for these problems do not necessarily guarantee fault-tolerance or load-balance properties. We propose  and study &#39;&#39;low-average degree&#39;&#39; or ``sparse&#39;&#39; versions of such structures. Interestingly, in sharp contrast to, say, MIS&#39;s, it can be shown that checking whether a structure is sparse, will take substantial time. Nevertheless, we are able to develop good  sequential/distributed (randomized) algorithms for such sparse versions.  We also complement our algorithms with several lower bounds. Randomization plays a key role in our upper and lower bound results.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">DEX: Self-Healing Expanders</span><a href="http://dx.doi.org/10.1007/s00446-015-0258-3" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Gopal Pandurangan, Peter Robinson, Amitabh Trehan. <span class="publicationInfo">Distributed Computing</span> (<span class="publicationConfShort">DC</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">We present a fully-distributed self-healing algorithm DEX, that  maintains a  constant degree expander network  in a dynamic setting.  To the best of our knowledge, our algorithm provides  the first  efficient distributed construction of   expanders  --- whose expansion properties  hold deterministically  --- that works even under an all-powerful adaptive adversary that controls the dynamic changes to the network (the adversary has unlimited computational power and knowledge of the  entire network state, can decide which nodes join and leave and at what time, and knows the past random choices made by the algorithm).  Previous distributed expander constructions  typically provide only probabilistic guarantees on the network expansion  which rapidly degrade in a dynamic setting; in particular, the expansion properties can  degrade even more rapidly under  adversarial insertions and deletions.  Our algorithm provides efficient maintenance  and incurs a low overhead per insertion/deletion by an adaptive adversary: only  $O(\log n)$  rounds and $O(\log n)$ messages are needed with high probability  ($n$ is the number of nodes currently in the network). The algorithm requires only a constant number of topology changes.  Moreover, our algorithm allows for an efficient implementation and maintenance of a distributed hash table (DHT) on top of DEX, with only a constant additional overhead. Our results are a step towards implementing  efficient self-healing  networks that have guaranteed properties (constant bounded degree and expansion)   despite  dynamic changes.</div></li></ul></div><div class="yearContainer"><span class="year">2015</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Distributed Computation of Large-scale Graph Problems</span><a href="https://www.dropbox.com/s/bgu7ug5kef51375/SODA2015.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://dx.doi.org/10.1137/1.9781611973730.28" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Hartmut Klauck, Danupon Nanongkai, Gopal Pandurangan, Peter Robinson. <span class="publicationInfo">26th ACM-SIAM Symposium on Discrete Algorithms</span> (<span class="publicationConfShort">SODA 2015</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">Motivated by the increasing need for fast distributed processing of  large-scale graphs such as the Web graph and various social networks, we study a number of fundamental  graph problems in the message-passing model, where we have $k$ machines that jointly perform computation on an arbitrary $n$-node (typically, $n \gg k$) input graph. The graph is  assumed to be  randomly  partitioned among the $k  \geq 2$ machines (a common implementation in many real world systems).  The communication is point-to-point, and the goal is to minimize the  time complexity, i.e., the number of communication rounds, of solving various fundamental graph problems.  We present lower bounds that quantify the fundamental time limitations of distributively solving graph  problems.  We first show a lower bound of $\Omega(n/k)$ rounds for  computing a spanning tree (ST) of the input graph. This result also implies the same bound for other fundamental problems such as computing a minimum spanning tree (MST), breadth-first tree (BFS), and shortest paths tree (SPT).    We also show an $\Omega(n/k^2)$ lower bound for connectivity, ST verification and other related problems. Our lower bounds develop and use new bounds in  random-partition communication complexity. To complement our lower bounds, we also  give  algorithms for various fundamental graph problems, e.g., PageRank, MST, connectivity, ST verification, shortest paths, cuts, spanners, covering problems, densest subgraph, subgraph isomorphism, finding triangles, etc. We show that problems such as PageRank, MST,  connectivity, and graph covering  can be solved in $\tilde{O}(n/k)$ time (the notation $\tilde O$ hides $\text{polylog}(n)$ factors and an additive $\text{polylog}(n)$ term); this shows that one can achieve almost linear (in $k$) speedup, whereas for shortest paths, we present  algorithms that run in $\tilde{O}(n/\sqrt{k})$ time (for $(1+\epsilon)$-factor approximation) and in $\tilde{O}(n/k)$ time (for $O(\log n)$-factor approximation) respectively. Our results are a step towards  understanding  the complexity of distributively solving large-scale graph problems.</div></li></ul></div><div class="yearContainer"><span class="year">2014</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">DEX: Self-Healing Expanders</span><a href="https://www.dropbox.com/s/2gplsnd7ibzj9fh/IPDPS2014.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://dx.doi.org/10.1109/IPDPS.2014.78" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Gopal Pandurangan, Peter Robinson, Amitabh Trehan. <span class="publicationInfo">28th IEEE International Parallel  Distributed Processing Symposium</span> (<span class="publicationConfShort">IPDPS 2014</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">We present a fully-distributed self-healing algorithm DEX, that  maintains a  constant degree expander network  in a dynamic setting.  To the best of our knowledge, our algorithm provides  the first  efficient distributed construction of   expanders  --- whose expansion properties  hold deterministically  --- that works even under an all-powerful adaptive adversary that controls the dynamic changes to the network (the adversary has unlimited computational power and knowledge of the  entire network state, can decide which nodes join and leave and at what time, and knows the past random choices made by the algorithm).  Previous distributed expander constructions  typically provide only probabilistic guarantees on the network expansion  which rapidly degrade in a dynamic setting; in particular, the expansion properties can  degrade even more rapidly under  adversarial insertions and deletions.  Our algorithm provides efficient maintenance  and incurs a low overhead per insertion/deletion by an adaptive adversary: only  $O(\log n)$  rounds and $O(\log n)$ messages are needed with high probability  ($n$ is the number of nodes currently in the network). The algorithm requires only a constant number of topology changes.  Moreover, our algorithm allows for an efficient implementation and maintenance of a distributed hash table (DHT) on top of DEX, with only a constant additional overhead. Our results are a step towards implementing  efficient self-healing  networks that have guaranteed properties (constant bounded degree and expansion)   despite  dynamic changes.</div></li><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Distributed Symmetry Breaking in Hypergraphs</span><a href="https://www.dropbox.com/s/5i7iyxfe0f3tsge/DISC2014.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://link.springer.com/chapter/10.1007%2F978-3-662-45174-8_32" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>Shay Kutten, Danupon Nanongkai, Gopal Pandurangan, Peter Robinson. <span class="publicationInfo">28th International Symposium on Distributed Computing</span> (<span class="publicationConfShort">DISC 2014</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">Fundamental local symmetry breaking  problems such as Maximal Independent Set (MIS) and coloring have been recognized as important by the community, and studied extensively in (standard) graphs. In particular, fast (i.e., logarithmic run time)   randomized algorithms are well-established for MIS and $\Delta +1$-coloring in both the LOCAL and CONGEST distributed computing models.  On the other hand, comparatively much less is known on the complexity of distributed symmetry breaking in hypergraphs.  In particular,  a key question is  whether a fast (randomized) algorithm for MIS exists  for hypergraphs. In this paper, we study the distributed complexity of symmetry breaking in hypergraphs   by presenting distributed randomized algorithms for a variety of fundamental problems under a natural distributed computing model for hypergraphs.    We first show that MIS in hypergraphs (of arbitrary dimension) can be solved in $O(\log^2 n)$ rounds  ($n$ is the number of nodes of the hypergraph) in the LOCAL  model.  We then present a key result of this paper ---  an $O(\Delta^{\epsilon}\text{poly} \log n)$-round   hypergraph MIS algorithm in the CONGEST model  where  $\Delta$ is the maximum node degree of the hypergraph and $\epsilon &gt; 0$ is any arbitrarily small constant. To demonstrate the usefulness of hypergraph MIS, we present applications of our hypergraph algorithm to solving problems in (standard) graphs.  In particular, the hypergraph MIS yields fast distributed algorithms for the  balanced minimal dominating set problem (left open in Harris et al. [ICALP 2013]) and the minimal connected dominating set  problem.  We also present distributed algorithms for coloring, maximal matching, and maximal clique in hypergraphs. Our work shows that while some local symmetry breaking problems such as coloring can be solved in polylogarithmic rounds in both the LOCAL and CONGEST models, for many other hypergraph problems  such as MIS, hitting set, and maximal clique, it remains challenging to obtain polylogarithmic time algorithms in the CONGEST model.  This work is a step towards understanding this dichotomy in the complexity of hypergraph problems as well as using hypergraphs to design fast distributed algorithms for problems in (standard) graphs.</div></li></ul></div><div class="yearContainer"><span class="year">2013</span><ul class="yearList fa-ul"><li class="entry"><i class="fa fa-li fa-caret-right"></i><span class="publicationTitle">Efficient Computation of Balanced Structures</span><a href="https://www.dropbox.com/s/ltewzhayfgy9q7f/ICALP2013.pdf?dl=0" target="_new" class="icon"><span class="fa fa-file-pdf-o fa-lg">PDF</span></a><a href="http://dx.doi.org/10.1007/978-3-642-39212-2_51" target="_new" class="icon"><span class="fa fa-external-link fa-lg">DOI</span></a><br>David G. Harris, Ehab Morsy, Gopal Pandurangan, Peter Robinson, Aravind Srinivasan. <span class="publicationInfo">40th International Colloquium on Automata, Languages and Programming</span> (<span class="publicationConfShort">ICALP 2013</span>). <br><a class="abstractToggle invisibleAbstract"><span class="fa fa-plus-square-o">Abstract</span></a><div class="abstract">Basic graph structures such as maximal independent sets (MIS’s) have spurred much theoretical research in distributed algorithms, and have several applications in networking and distributed computing as well.  However, the extant (distributed) algorithms for these problems do not necessarily guarantee fault-tolerance or load-balance properties: For example, in a star-graph, the central vertex, as well as the set of leaves, are both MIS’s, with the latter being much more fault-tolerant and balanced - existing distributed algorithms do not handle this distinction. We propose and study &quot;low-average degree&quot; or &quot;balanced&quot; versions of such structures.  Interestingly, in sharp contrast to, say, MIS’s, it can be shown that checking whether a structure is balanced, will take substantial time.  Nevertheless, we are able to develop good sequential and distributed algorithms for such &quot;balanced&quot; versions. We also complement our algorithms with lower bounds.</div></li></ul></div></div><div class="intro revealOnScroll"><h2><a class="anchor" id="Code">Code</a></h2><div>I&#39;m interested in parallel and distributed programming and related technologies such as software transactional memory and the actor-model. Recently, I have been working on implementing a simulation environment for distributed algorithms in Elixir/Erlang, and implementing non-blocking data structures in Haskell suitable for multi-core machines. Below is a (non-comprehensive) list of software that I have written. </div><ul class="longList fa-ul"><li><i class="fa fa-li fa-caret-right"></i><a class="external" href="http://hackage.haskell.org/package/concurrent-hashtable">concurrent hash table:</a> a thread-safe hash table that scales to multicores.</li><li><i class="fa fa-li fa-caret-right"></i><a class="external" href="http://hackage.haskell.org/package/data-dispersal">data dispersal:</a> an implementation of an (m,n)-threshold information dispersal scheme that is space-optimal.</li><li><i class="fa fa-li fa-caret-right"></i><a class="external" href="http://hackage.haskell.org/package/secret-sharing">secret sharing:</a> an implementation of a secret sharing scheme that provides information-theoretic security.</li><li><i class="fa fa-li fa-caret-right"></i><a class="external" href="http://hackage.haskell.org/package/tskiplist">tskiplist:</a> a data structure with range-query support for software transactional memory.</li><li><i class="fa fa-li fa-caret-right"></i><a class="external" href="http://hackage.haskell.org/package/stm-io-hooks">stm-io-hooks:</a> An extension of Haskell&#39;s Software Transactional Memory (STM) monad with commit and retry IO hooks.</li><li><i class="fa fa-li fa-caret-right"></i><a class="external" href="http://hackage.haskell.org/package/mathgenealogy">Mathgenealogy:</a> Visualize your (academic) genealogy! A program for extracting data from the Mathematics Genealogy project.</li><li><i class="fa fa-li fa-caret-right"></i>I extended Haskell&#39;s <a class="external" href="https://www.haskell.org/cabal/">Cabal,</a> for using a &quot;world&quot; file to keep track of installed packages.  (Now part of the main distribution.)</li></ul></div><div class="intro revealOnScroll" id="teaching"><h2><a class="anchor" id="Teaching">Teaching</a></h2><ul class="longList fa-ul"><li><i class="fa fa-li fa-caret-right"></i>CAS781 Randomized Algorithms, Fall 2018: <a class="external" href="https://www.cas.mcmaster.ca/robinson/teaching/cas781/markov/">More slides.</a><a class="external" href="https://www.cas.mcmaster.ca/robinson/teaching/cas781/intro_slides/">Intro slides.</a></li><li><i class="fa fa-li fa-caret-right"></i>CS5860 Advanced Distributed Systems, Fall 2016, 2017.</li><li><i class="fa fa-li fa-caret-right"></i>CS5800 Computation with Data, Fall 2016.</li><li><i class="fa fa-li fa-caret-right"></i>BI5632 Internet and Web Technologies, Spring 2016.</li><li><i class="fa fa-li fa-caret-right"></i>CSC2008 Networks and Communications, Fall 2015.</li></ul></div><div class="intro revealOnScroll" id="misc"><h2><a class="anchor" id="Misc">Misc</a></h2><ul class="longList fa-ul"><li><i class="fa fa-li fa-caret-right"></i>Google scholar <a class="external" href="http://scholar.google.com.sg/citations?user=DsPjnMQAAAAJ&amp;hl=en">profile</a></li><li><i class="fa fa-li fa-caret-right"></i>My profile on <a class="external" href="http://stackexchange.com/users/555378/monoid">StackExchange</a></li></ul></div></div></div></div></body></html>